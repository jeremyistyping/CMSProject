package models

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"
	"gorm.io/gorm"
)

// JournalEntry represents a complete journal entry in the double-entry bookkeeping system
type JournalEntry struct {
	ID              uint           `json:"id" gorm:"primaryKey"`
	JournalID       *uint          `json:"journal_id" gorm:"index"`                   // Reference to parent journal (optional)
	AccountID       *uint          `json:"account_id" gorm:"index"`                   // Primary account ID for simple entries
	Code            string         `json:"code" gorm:"unique;not null;size:30;index"` // JE-YYYY-MM-XXXX
	Description     string         `json:"description" gorm:"not null;type:text"`
	Reference       string         `json:"reference" gorm:"size:100"`                 // Reference to source transaction
	ReferenceType   string         `json:"reference_type" gorm:"size:50"`             // SALE, PURCHASE, PAYMENT, MANUAL, etc.
	ReferenceID     *uint          `json:"reference_id" gorm:"index"`                 // ID of source transaction
	EntryDate       time.Time      `json:"entry_date" gorm:"not null"`               // Journal entry date
	PostingDate     *time.Time     `json:"posting_date"`                             // When posted to GL
	UserID          uint           `json:"user_id" gorm:"not null;index"`            // User who created the entry
	PostedBy        *uint          `json:"posted_by" gorm:"index"`                   // User who posted the entry
	Status          string         `json:"status" gorm:"size:20;default:'DRAFT'"`    // DRAFT, POSTED, REVERSED
	TotalDebit      float64        `json:"total_debit" gorm:"type:decimal(20,2);default:0"`
	TotalCredit     float64        `json:"total_credit" gorm:"type:decimal(20,2);default:0"`
	IsBalanced      bool           `json:"is_balanced" gorm:"default:false"`         // Auto-calculated: debit = credit
	IsAutoGenerated bool           `json:"is_auto_generated" gorm:"default:false"`   // Auto vs Manual entry
	ReversalID      *uint          `json:"reversal_id" gorm:"index"`                 // Points to reversing entry
	ReversedID      *uint          `json:"reversed_id" gorm:"index"`                 // Points to original entry being reversed
	Notes           string         `json:"notes" gorm:"type:text"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	DeletedAt       gorm.DeletedAt `json:"-" gorm:"index"`

	// Relations
	Journal        *Journal              `json:"journal,omitempty" gorm:"foreignKey:JournalID"`
	Account        *Account              `json:"account,omitempty" gorm:"foreignKey:AccountID"`
	Creator        User                  `json:"creator" gorm:"foreignKey:UserID"`
	Poster         *User                 `json:"poster,omitempty" gorm:"foreignKey:PostedBy"`
	JournalLines   []JournalLine         `json:"journal_lines" gorm:"foreignKey:JournalEntryID"`
	ReversalEntry  *JournalEntry         `json:"reversal_entry,omitempty" gorm:"foreignKey:ReversalID"`
	ReversedEntry  *JournalEntry         `json:"reversed_entry,omitempty" gorm:"foreignKey:ReversedID"`
}

// JournalLine represents individual debit/credit lines in a journal entry
type JournalLine struct {
	ID             uint           `json:"id" gorm:"primaryKey"`
	JournalEntryID uint           `json:"journal_entry_id" gorm:"not null;index"`
	AccountID      uint           `json:"account_id" gorm:"not null;index"`
	Description    string         `json:"description" gorm:"type:text"`
	DebitAmount    float64        `json:"debit_amount" gorm:"type:decimal(20,2);default:0"`
	CreditAmount   float64        `json:"credit_amount" gorm:"type:decimal(20,2);default:0"`
	LineNumber     int            `json:"line_number" gorm:"not null"`               // Order of lines in entry
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	DeletedAt      gorm.DeletedAt `json:"-" gorm:"index"`

	// Relations
	JournalEntry JournalEntry `json:"-" gorm:"foreignKey:JournalEntryID"` // Exclude to prevent circular reference
	Account      Account      `json:"account" gorm:"foreignKey:AccountID"`
}

// Journal Entry Status Constants
const (
	JournalStatusDraft    = "DRAFT"
	JournalStatusPosted   = "POSTED"
	JournalStatusReversed = "REVERSED"
	JournalStatusApproved = "APPROVED"
)

// Journal Entry Reference Types Constants
const (
	JournalRefSale     = "SALE"
	JournalRefPurchase = "PURCHASE"
	JournalRefPayment  = "PAYMENT"
	JournalRefCashBank = "CASH_BANK"
	JournalRefAsset    = "ASSET"
	JournalRefManual   = "MANUAL"
	JournalRefOpening  = "OPENING_BALANCE"
	JournalRefClosing  = "CLOSING_BALANCE"
	JournalRefTransfer = "TRANSFER"
	JournalRefDeposit  = "DEPOSIT"
	JournalRefWithdrawal = "WITHDRAWAL"
	JournalRefInterest = "INTEREST"
)

// Request/Response DTOs
type JournalEntryCreateRequest struct {
	Description     string    `json:"description" binding:"required"`
	Reference       string    `json:"reference"`
	ReferenceType   string    `json:"reference_type"`
	ReferenceID     *uint     `json:"reference_id"`
	EntryDate       time.Time `json:"entry_date" binding:"required"`
	Notes           string    `json:"notes"`
	UserID          uint      `json:"user_id" binding:"required"`
	AccountID       *uint     `json:"account_id"`
	TotalDebit      float64   `json:"total_debit"`
	TotalCredit     float64   `json:"total_credit"`
	IsAutoGenerated bool      `json:"is_auto_generated"`
}

type JournalLineCreateRequest struct {
	AccountID     uint    `json:"account_id" binding:"required"`
	Description   string  `json:"description"`
	DebitAmount   float64 `json:"debit_amount"`
	CreditAmount  float64 `json:"credit_amount"`
}

type JournalEntryUpdateRequest struct {
	Description  *string                     `json:"description"`
	Reference    *string                     `json:"reference"`
	EntryDate    *time.Time                  `json:"entry_date"`
	Notes        *string                     `json:"notes"`
	JournalLines []JournalLineCreateRequest  `json:"journal_lines"`
}

// Validation methods
func (je *JournalEntry) ValidateBalance() bool {
	// If we have journal lines, calculate from lines
	if len(je.JournalLines) > 0 {
		var totalDebit, totalCredit float64
		
		for _, line := range je.JournalLines {
			totalDebit += line.DebitAmount
			totalCredit += line.CreditAmount
		}
		
		je.TotalDebit = totalDebit
		je.TotalCredit = totalCredit
	} else {
		// For simplified entries without lines, validate the totals directly
		// Ensure totals are properly set and not zero
		if je.TotalDebit == 0 && je.TotalCredit == 0 {
			je.IsBalanced = false
			return false
		}
	}
	
	// Balance validation: debit must equal credit and both must be positive
	je.IsBalanced = (je.TotalDebit == je.TotalCredit) && (je.TotalDebit > 0)
	
	return je.IsBalanced
}

// ValidateAmounts validates that amounts are not negative and not excessively large
func (je *JournalEntry) ValidateAmounts() error {
	const maxAmount = 999999999999.99 // Maximum for decimal(15,2)
	
	if je.TotalDebit < 0 || je.TotalCredit < 0 {
		return fmt.Errorf("journal entry amounts cannot be negative")
	}
	
	if je.TotalDebit > maxAmount || je.TotalCredit > maxAmount {
		return fmt.Errorf("journal entry amounts exceed maximum allowed value")
	}
	
	return nil
}

// ValidateComplete performs comprehensive validation
func (je *JournalEntry) ValidateComplete() error {
	// 1. Validate amounts
	if err := je.ValidateAmounts(); err != nil {
		return err
	}
	
	// 2. Validate balance
	if !je.ValidateBalance() {
		return fmt.Errorf("journal entry is not balanced: debit=%.2f, credit=%.2f", je.TotalDebit, je.TotalCredit)
	}
	
	// 3. Validate required fields
	if strings.TrimSpace(je.Description) == "" {
		return fmt.Errorf("journal entry description is required")
	}
	
	if je.UserID == 0 {
		return fmt.Errorf("journal entry user ID is required")
	}
	
	// 4. Validate entry date
	if je.EntryDate.IsZero() {
		return fmt.Errorf("journal entry date is required")
	}
	
	// Future date validation (allow max 7 days in future)
	// Exception: Skip validation for period closing entries which may have future dates
	if je.ReferenceType != JournalRefClosing && je.EntryDate.After(time.Now().AddDate(0, 0, 7)) {
		return fmt.Errorf("journal entry date cannot be more than 7 days in the future")
	}
	
	return nil
}

// ValidateBusinessRules performs comprehensive business rule validation
func (je *JournalEntry) ValidateBusinessRules(tx *gorm.DB) error {
	// 1. Balance validation
	if !je.ValidateBalance() {
		return errors.New("journal entry is not balanced")
	}
	
	// 2. Amount validation
	if je.TotalDebit < 0 || je.TotalCredit < 0 {
		return errors.New("journal amounts cannot be negative")
	}
	
	if je.TotalDebit == 0 && je.TotalCredit == 0 {
		return errors.New("journal entry cannot have zero amounts")
	}
	
	// 3. Date validation
	if je.EntryDate.IsZero() {
		return errors.New("entry date is required")
	}
	
	// Future date validation (allow max 7 days in future)
	// Exception: Skip validation for period closing entries which may have future dates
	if je.ReferenceType != JournalRefClosing && je.EntryDate.After(time.Now().AddDate(0, 0, 7)) {
		return errors.New("entry date cannot be more than 7 days in the future")
	}
	
	// 4. Account validation
	if err := je.validateAccountCompatibility(tx); err != nil {
		return err
	}
	
	// 5. Required fields validation
	if strings.TrimSpace(je.Description) == "" {
		return errors.New("description is required")
	}
	
	if je.UserID == 0 {
		return errors.New("user ID is required")
	}
	
	return nil
}

// validateAccountCompatibility validates account-related business rules
func (je *JournalEntry) validateAccountCompatibility(tx *gorm.DB) error {
	for _, line := range je.JournalLines {
		var account Account
		if err := tx.First(&account, line.AccountID).Error; err != nil {
			return fmt.Errorf("account %d not found", line.AccountID)
		}
		
		// Check if account is active
		if !account.IsActive {
			return fmt.Errorf("account %s (%s) is inactive", account.Name, account.Code)
		}
		
		// Check if account is header account
		if account.IsHeader {
			return fmt.Errorf("cannot post to header account %s (%s)", account.Name, account.Code)
		}
		
		// Validate line amounts
		if line.DebitAmount < 0 || line.CreditAmount < 0 {
			return fmt.Errorf("line amounts cannot be negative for account %s", account.Name)
		}
		
		if line.DebitAmount > 0 && line.CreditAmount > 0 {
			return fmt.Errorf("line cannot have both debit and credit amounts for account %s", account.Name)
		}
		
		if line.DebitAmount == 0 && line.CreditAmount == 0 {
			return fmt.Errorf("line must have either debit or credit amount for account %s", account.Name)
		}
	}
	
	return nil
}


// GORM Hooks
func (je *JournalEntry) BeforeCreate(tx *gorm.DB) error {
	// Generate journal entry code only if not provided
	if je.Code == "" {
		now := time.Now()
		year := now.Year()
		month := int(now.Month())
		day := now.Day()
		
		// Use a more reliable approach with date-based sequence
		var maxSequence int64
		
		// Get the highest sequence number for today using LIKE pattern to be more efficient
		datePrefix := fmt.Sprintf("JE-%04d-%02d-%02d-", year, month, day)
		
		// Query for entries with today's date prefix and extract sequence numbers
		var entries []JournalEntry
		tx.Select("code").Where("code LIKE ? AND created_at >= ? AND created_at < ?", 
			datePrefix+"%", 
			time.Date(year, time.Month(month), day, 0, 0, 0, 0, now.Location()),
			time.Date(year, time.Month(month), day+1, 0, 0, 0, 0, now.Location())).Find(&entries)
		
		// Find the maximum sequence number from existing codes
		for _, entry := range entries {
			if len(entry.Code) > len(datePrefix) {
				seqStr := entry.Code[len(datePrefix):]
				if seq, err := strconv.ParseInt(seqStr, 10, 64); err == nil {
					if seq > maxSequence {
						maxSequence = seq
					}
				}
			}
		}
		
		// Try to generate a unique code with retry logic
		for attempt := 1; attempt <= 50; attempt++ {
			sequence := maxSequence + int64(attempt)
			proposedCode := fmt.Sprintf("%s%04d", datePrefix, sequence)
			
			// Double-check if this code exists (extra safety)
			var existingCount int64
			tx.Model(&JournalEntry{}).Where("code = ?", proposedCode).Count(&existingCount)
			
			if existingCount == 0 {
				je.Code = proposedCode
				return nil
			}
		}
		
		// Ultimate fallback - use nanosecond timestamp to ensure uniqueness
		je.Code = fmt.Sprintf("JE-%04d-%02d-%02d-%d", year, month, day, now.UnixNano()%1000000)
	}
	return nil
}

func (je *JournalEntry) BeforeSave(tx *gorm.DB) error {
	// Always validate balance before saving
	if !je.ValidateBalance() {
		return fmt.Errorf("journal entry is not balanced: debit=%.2f, credit=%.2f", je.TotalDebit, je.TotalCredit)
	}
	return nil
}

// Auto-generate journal entries for sales
func GenerateSaleJournalEntry(sale Sale) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Sales Invoice %s - %s", sale.Code, sale.Customer.Name),
		Reference:       sale.Code,
		ReferenceType:   JournalRefSale,
		ReferenceID:     &sale.ID,
		EntryDate:       sale.Date,
		UserID:          sale.UserID,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
	}

	// Generate journal lines
	var lines []JournalLine

	// 1. Debit: Accounts Receivable (if not cash sale)
	if sale.OutstandingAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1201, // Piutang Usaha account ID
			Description:  fmt.Sprintf("Accounts Receivable - %s", sale.Customer.Name),
			DebitAmount:  sale.OutstandingAmount,
			LineNumber:   1,
		})
	}

	// 2. Debit: Cash/Bank (if cash received)
	if sale.PaidAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1101, // Kas account ID
			Description:  fmt.Sprintf("Cash Received - %s", sale.Customer.Name),
			DebitAmount:  sale.PaidAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 3. Credit: Sales Revenue
	for _, item := range sale.SaleItems {
		lines = append(lines, JournalLine{
			AccountID:    item.RevenueAccountID,
			Description:  fmt.Sprintf("Sales Revenue - %s", item.Product.Name),
			CreditAmount: item.LineTotal,
			LineNumber:   len(lines) + 1,
		})
	}

	// 4. Credit: PPN Payable (if applicable)
	if sale.PPN > 0 {
		lines = append(lines, JournalLine{
			AccountID:    2101, // PPN Keluaran account ID
			Description:  "PPN Keluaran",
			CreditAmount: sale.PPN,
			LineNumber:   len(lines) + 1,
		})
	}

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Auto-generate journal entries for asset purchase
func GenerateAssetJournalEntry(asset Asset, userId uint, paymentMethod string, paymentAccountID *uint, creditAccountID *uint) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Asset Purchase - %s (%s)", asset.Name, asset.Code),
		Reference:       asset.Code,
		ReferenceType:   JournalRefAsset,
		ReferenceID:     &asset.ID,
		EntryDate:       asset.PurchaseDate,
		UserID:          userId,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
		TotalDebit:      asset.PurchasePrice,
		TotalCredit:     asset.PurchasePrice,
		IsBalanced:      true,
	}

	var lines []JournalLine

	// 1. Debit: Fixed Asset Account - Use fallback to prevent errors
	var assetAccountID uint = 1 // Safe fallback - will be updated when proper accounts exist
	if asset.AssetAccountID != nil {
		// Use provided asset account ID
		assetAccountID = *asset.AssetAccountID
	}

	lines = append(lines, JournalLine{
		AccountID:    assetAccountID,
		Description:  fmt.Sprintf("Asset Purchase - %s", asset.Name),
		DebitAmount:  asset.PurchasePrice,
		LineNumber:   1,
	})

	// 2. Credit: Cash, Bank, or Accounts Payable based on selection
	var finalCreditAccountID uint
	var creditDescription string

	switch paymentMethod {
	case "CASH":
		if paymentAccountID != nil {
			finalCreditAccountID = *paymentAccountID // Use selected cash account
		} else {
			finalCreditAccountID = 1101 // Default Kas account ID
		}
		creditDescription = fmt.Sprintf("Cash Payment for %s", asset.Name)
	case "BANK":
		if paymentAccountID != nil {
			finalCreditAccountID = *paymentAccountID // Use selected bank account
		} else {
			finalCreditAccountID = 1102 // Default Bank account ID
		}
		creditDescription = fmt.Sprintf("Bank Transfer for %s", asset.Name)
	case "CREDIT":
		if creditAccountID != nil {
			finalCreditAccountID = *creditAccountID // Use selected liability account
		} else {
			finalCreditAccountID = 1 // Safe fallback - will be updated when proper accounts exist
		}
		creditDescription = fmt.Sprintf("Asset Purchase on Credit - %s", asset.Name)
	default:
		// Default to accounts payable for credit purchase
		if creditAccountID != nil {
			finalCreditAccountID = *creditAccountID
		} else {
			finalCreditAccountID = 1 // Safe fallback
		}
		creditDescription = fmt.Sprintf("Asset Purchase on Credit - %s", asset.Name)
	}

	lines = append(lines, JournalLine{
		AccountID:    finalCreditAccountID,
		Description:  creditDescription,
		CreditAmount: asset.PurchasePrice,
		LineNumber:   2,
	})

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Auto-generate depreciation journal entry
func GenerateDepreciationJournalEntry(asset Asset, depreciationAmount float64, userId uint, entryDate time.Time) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Monthly Depreciation - %s (%s)", asset.Name, asset.Code),
		Reference:       fmt.Sprintf("%s-DEP-%s", asset.Code, entryDate.Format("2006-01")),
		ReferenceType:   "DEPRECIATION",
		ReferenceID:     &asset.ID,
		EntryDate:       entryDate,
		UserID:          userId,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
		TotalDebit:      depreciationAmount,
		TotalCredit:     depreciationAmount,
		IsBalanced:      true,
	}

	var lines []JournalLine

	// 1. Debit: Depreciation Expense
	depreciationExpenseAccountID := uint(6201) // Default Depreciation Expense account ID
	if asset.DepreciationAccountID != nil {
		depreciationExpenseAccountID = *asset.DepreciationAccountID
	}

	lines = append(lines, JournalLine{
		AccountID:    depreciationExpenseAccountID,
		Description:  fmt.Sprintf("Depreciation Expense - %s", asset.Name),
		DebitAmount:  depreciationAmount,
		LineNumber:   1,
	})

	// 2. Credit: Accumulated Depreciation
	accumulatedDepreciationAccountID := uint(1501) // Accumulated Depreciation contra-asset account

	lines = append(lines, JournalLine{
		AccountID:    accumulatedDepreciationAccountID,
		Description:  fmt.Sprintf("Accumulated Depreciation - %s", asset.Name),
		CreditAmount: depreciationAmount,
		LineNumber:   2,
	})

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Auto-generate journal entries for purchases
func GeneratePurchaseJournalEntry(purchase Purchase) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Purchase Invoice %s - %s", purchase.Code, purchase.Vendor.Name),
		Reference:       purchase.Code,
		ReferenceType:   JournalRefPurchase,
		ReferenceID:     &purchase.ID,
		EntryDate:       purchase.Date,
		UserID:          purchase.UserID,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
	}

	var lines []JournalLine

	// 1. Debit: Expense/Inventory Accounts
	for _, item := range purchase.PurchaseItems {
		lines = append(lines, JournalLine{
			AccountID:    item.ExpenseAccountID,
			Description:  fmt.Sprintf("Purchase - %s", item.Product.Name),
			DebitAmount:  item.TotalPrice,
			LineNumber:   len(lines) + 1,
		})
	}

	// 2. Debit: PPN Masukan (if applicable)
	if purchase.PPNAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1105, // PPN Masukan account ID
			Description:  "PPN Masukan",
			DebitAmount:  purchase.PPNAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 3. Credit: Accounts Payable (if not cash purchase)
	if purchase.OutstandingAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    2001, // Hutang Usaha account ID
			Description:  fmt.Sprintf("Accounts Payable - %s", purchase.Vendor.Name),
			CreditAmount: purchase.OutstandingAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 4. Credit: Cash/Bank (if cash paid)
	if purchase.PaidAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1101, // Kas account ID
			Description:  fmt.Sprintf("Cash Paid - %s", purchase.Vendor.Name),
			CreditAmount: purchase.PaidAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Journal Entry Filter for listing
type JournalEntryFilter struct {
	Status        string `json:"status"`
	ReferenceType string `json:"reference_type"`
	AccountID     string `json:"account_id"`
	StartDate     string `json:"start_date"`
	EndDate       string `json:"end_date"`
	Search        string `json:"search"`
	Page          int    `json:"page"`
	Limit         int    `json:"limit"`
}

// Journal Entry Summary for reporting
type JournalEntrySummary struct {
	TotalEntries   int64              `json:"total_entries"`
	TotalDebit     float64            `json:"total_debit"`
	TotalCredit    float64            `json:"total_credit"`
	BalancedEntries int64             `json:"balanced_entries"`
	StatusCounts   map[string]int64   `json:"status_counts"`
	TypeCounts     map[string]int64   `json:"type_counts"`
}
