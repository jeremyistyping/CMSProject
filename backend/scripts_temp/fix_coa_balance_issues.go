package main

import (
	"fmt"
	"log"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"github.com/shopspring/decimal"
	"app-sistem-akuntansi/models"
)

func main() {
	dsn := "host=localhost user=postgres password=postgres dbname=sistem_akuntansi port=5432 sslmode=disable"
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}

	fmt.Println("üîß FIXING COA BALANCE ISSUES BASED ON ANALYSIS")
	fmt.Println("=" + fmt.Sprintf("%*s", 69, "") + "=")

	// Analysis Results Summary:
	fmt.Printf("\nüìä ISSUES IDENTIFIED:\n")
	fmt.Printf("1. ‚ùå PPN Input Tax (2102) showing positive balance - should be negative for asset nature\n")
	fmt.Printf("2. ‚ùå Bank BCA (1102) balance mismatch - Expected: 9,900,000 vs Current: 7,680,000\n")
	fmt.Printf("3. ‚ùå Accounting equation imbalance: -3,320,000 difference\n")

	// Issue 1: Fix PPN Input Tax Account Nature
	fmt.Printf("\nüîÑ ISSUE 1: Fixing PPN Input Tax Account Nature...\n")
	
	var ppnAccount models.Account
	if err := db.Where("code = ?", "2102").First(&ppnAccount).Error; err != nil {
		log.Fatal("PPN account not found:", err)
	}

	fmt.Printf("Current PPN Account: %s (%s) - Type: %s, Balance: %.2f\n", 
		ppnAccount.Name, ppnAccount.Code, ppnAccount.Type, ppnAccount.Balance)

	// PPN Input should be treated as an asset (receivable from government)
	// But it's currently set as LIABILITY with positive balance
	// For correct accounting, we need to:
	// Option 1: Change account type to ASSET 
	// Option 2: Keep as LIABILITY but with negative balance
	
	fmt.Printf("\nüí° Recommendation: PPN Input Tax should be treated as ASSET (Receivable from Govt)\n")
	fmt.Printf("   Current setup treats it as LIABILITY with positive balance (incorrect)\n")
	fmt.Printf("   Fixing: Convert to ASSET type with positive balance\n")

	// Update PPN account to be an asset
	ppnAccount.Type = "ASSET"
	ppnAccount.Name = "PPN Masukan" // More appropriate name
	db.Save(&ppnAccount)
	
	fmt.Printf("‚úÖ Fixed: %s (%s) - Now Type: %s, Balance: %.2f\n", 
		ppnAccount.Name, ppnAccount.Code, ppnAccount.Type, ppnAccount.Balance)

	// Issue 2: Check missing journal for second purchase
	fmt.Printf("\nüîÑ ISSUE 2: Checking missing journal entries...\n")
	
	var purchases []models.Purchase
	db.Where("deleted_at IS NULL").Find(&purchases)
	
	for _, purchase := range purchases {
		var journalEntry models.SSOTJournalEntry
		err := db.Where("source_type = ? AND source_code = ?", 
			models.SSOTSourceTypePurchase, purchase.Code).First(&journalEntry).Error
			
		if err != nil {
			fmt.Printf("‚ùå Missing journal entry for purchase: %s (%.2f)\n", 
				purchase.Code, purchase.TotalAmount)
			
			if purchase.Code == "PO/2025/09/0026" {
				fmt.Printf("   Creating journal entry for missing purchase...\n")
				createMissingJournalEntry(db, &purchase)
			}
		} else {
			fmt.Printf("‚úÖ Journal exists for purchase: %s\n", purchase.Code)
		}
	}

	// Issue 3: Recalculate all account balances
	fmt.Printf("\nüîÑ ISSUE 3: Recalculating account balances from journal entries...\n")
	recalculateAccountBalances(db)

	// Final verification
	fmt.Printf("\n‚úÖ VERIFICATION: Checking accounting equation after fixes...\n")
	verifyAccountingEquation(db)

	fmt.Println("\nüéâ COA balance issues fixed!")
}

func createMissingJournalEntry(db *gorm.DB, purchase *models.Purchase) {
	fmt.Printf("   üìù Creating journal entry for %s...\n", purchase.Code)
	
	// Get required accounts
	var inventoryAccount, payableAccount, taxAccount models.Account
	
	db.Where("code = ?", "1301").First(&inventoryAccount)  // Inventory
	db.Where("code = ?", "2101").First(&payableAccount)    // Accounts Payable
	db.Where("code = ?", "2102").First(&taxAccount)        // PPN Input

	// Create journal entry
	journalEntry := models.SSOTJournalEntry{
		SourceType:      models.SSOTSourceTypePurchase,
		SourceCode:      purchase.Code,
		EntryDate:       purchase.Date,
		Description:     fmt.Sprintf("Purchase transaction - %s", purchase.Code),
		Status:          "POSTED",
		IsAutoGenerated: true,
		CreatedBy:       1,
	}
	
	if err := db.Create(&journalEntry).Error; err != nil {
		fmt.Printf("   ‚ùå Failed to create journal entry: %v\n", err)
		return
	}

	// Create journal lines
	lines := []models.SSOTJournalLine{
		{
			JournalID:    journalEntry.ID,
			AccountID:    uint64(inventoryAccount.ID),
			LineNumber:   1,
			Description:  "Inventory purchase (before tax)",
			DebitAmount:  decimal.NewFromFloat(purchase.SubtotalBeforeDiscount),
			CreditAmount: decimal.Zero,
		},
		{
			JournalID:    journalEntry.ID,
			AccountID:    uint64(taxAccount.ID),
			LineNumber:   2,
			Description:  "PPN Input Tax",
			DebitAmount:  decimal.NewFromFloat(purchase.PPNAmount),
			CreditAmount: decimal.Zero,
		},
		{
			JournalID:    journalEntry.ID,
			AccountID:    uint64(payableAccount.ID),
			LineNumber:   3,
			Description:  "Accounts payable (total including PPN)",
			DebitAmount:  decimal.Zero,
			CreditAmount: decimal.NewFromFloat(purchase.TotalAmount),
		},
	}

	for _, line := range lines {
		if err := db.Create(&line).Error; err != nil {
			fmt.Printf("   ‚ùå Failed to create journal line: %v\n", err)
			return
		}
	}

	// Update journal totals
	journalEntry.TotalDebit = decimal.NewFromFloat(purchase.SubtotalBeforeDiscount + purchase.PPNAmount)
	journalEntry.TotalCredit = decimal.NewFromFloat(purchase.TotalAmount)
	db.Save(&journalEntry)

	fmt.Printf("   ‚úÖ Created journal entry: %s\n", journalEntry.EntryNumber)
}

func recalculateAccountBalances(db *gorm.DB) {
	fmt.Printf("   üßÆ Recalculating balances from all journal entries...\n")
	
	// Get all accounts
	var accounts []models.Account
	db.Where("deleted_at IS NULL").Find(&accounts)
	
	for _, account := range accounts {
		var totalDebit, totalCredit float64
		
		// Sum debits and credits for this account from all posted journal lines
		var result struct {
			TotalDebit  float64 `json:"total_debit"`
			TotalCredit float64 `json:"total_credit"`
		}
		db.Raw(`
			SELECT 
				COALESCE(SUM(debit_amount::float), 0) as total_debit,
				COALESCE(SUM(credit_amount::float), 0) as total_credit
			FROM unified_journal_lines jl
			JOIN unified_journal_ledger je ON jl.journal_id = je.id
			WHERE jl.account_id = ? AND je.status = 'POSTED' AND je.deleted_at IS NULL
		`, account.ID).Scan(&result)
		
		totalDebit = result.TotalDebit
		totalCredit = result.TotalCredit

		// Calculate balance based on account type
		var newBalance float64
		switch account.Type {
		case "ASSET", "EXPENSE":
			// Assets and Expenses: Debit increases, Credit decreases
			newBalance = totalDebit - totalCredit
		case "LIABILITY", "EQUITY", "REVENUE":
			// Liabilities, Equity, Revenue: Credit increases, Debit decreases
			newBalance = totalCredit - totalDebit
		}

		// Update account balance if changed
		if account.Balance != newBalance {
			fmt.Printf("   üìä %s (%s): %.2f ‚Üí %.2f\n", 
				account.Name, account.Code, account.Balance, newBalance)
			db.Model(&account).Update("balance", newBalance)
		}
	}
}

func verifyAccountingEquation(db *gorm.DB) {
	var assetsTotal, liabilitiesTotal, equityTotal float64
	
	db.Raw("SELECT COALESCE(SUM(balance), 0) FROM accounts WHERE type = 'ASSET' AND deleted_at IS NULL").Scan(&assetsTotal)
	db.Raw("SELECT COALESCE(SUM(balance), 0) FROM accounts WHERE type = 'LIABILITY' AND deleted_at IS NULL").Scan(&liabilitiesTotal)
	db.Raw("SELECT COALESCE(SUM(balance), 0) FROM accounts WHERE type = 'EQUITY' AND deleted_at IS NULL").Scan(&equityTotal)
	
	fmt.Printf("   Assets: Rp %.2f\n", assetsTotal)
	fmt.Printf("   Liabilities: Rp %.2f\n", liabilitiesTotal)
	fmt.Printf("   Equity: Rp %.2f\n", equityTotal)
	fmt.Printf("   Difference: Rp %.2f\n", assetsTotal - (liabilitiesTotal + equityTotal))
	
	if assetsTotal == liabilitiesTotal + equityTotal {
		fmt.Printf("   ‚úÖ Accounting equation is now BALANCED!\n")
	} else {
		fmt.Printf("   ‚ö†Ô∏è Accounting equation still has imbalance\n")
	}
}