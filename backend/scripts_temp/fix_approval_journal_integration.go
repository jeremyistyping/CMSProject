package main

import (
	"fmt"
	"log"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"github.com/shopspring/decimal"
	"app-sistem-akuntansi/models"
)

func main() {
	// Database connection
	dsn := "host=localhost user=postgres password=postgres dbname=sistem_akuntansi port=5432 sslmode=disable"
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	log.Println("üîß Fixing Approval ‚Üí Journal Integration...")

	// Step 1: Check current approved purchases
	log.Println("\nüìä Step 1: Checking approved purchases without journal entries...")
	if err := checkApprovedPurchasesWithoutJournals(db); err != nil {
		log.Printf("‚ùå Failed to check purchases: %v", err)
	}

	// Step 2: Manually create journal entries for approved purchases
	log.Println("\nüèóÔ∏è Step 2: Creating missing journal entries for approved purchases...")
	if err := createMissingJournalEntries(db); err != nil {
		log.Printf("‚ùå Failed to create journal entries: %v", err)
	}

	// Step 3: Update COA balances
	log.Println("\nüí∞ Step 3: Updating COA balances...")
	if err := updateCOABalances(db); err != nil {
		log.Printf("‚ùå Failed to update balances: %v", err)
	}

	// Step 4: Verify integration is working
	log.Println("\nüîç Step 4: Verifying integration...")
	verifyIntegration(db)

	log.Println("\nüéâ Approval ‚Üí Journal Integration Fix Completed!")
}

func checkApprovedPurchasesWithoutJournals(db *gorm.DB) error {
	// Get all approved purchases
	var approvedPurchases []models.Purchase
	if err := db.Preload("Vendor").Where("status = ? AND approval_status = ?", 
		models.PurchaseStatusApproved, models.PurchaseApprovalApproved).Find(&approvedPurchases).Error; err != nil {
		return fmt.Errorf("failed to get approved purchases: %v", err)
	}

	log.Printf("   üìã Found %d approved purchases", len(approvedPurchases))

	for _, purchase := range approvedPurchases {
		// Check if this purchase has SSOT journal entries
		var journalCount int64
		db.Model(&models.SSOTJournalEntry{}).
			Where("source_type = ? AND source_id = ?", models.SSOTSourceTypePurchase, purchase.ID).
			Count(&journalCount)

		if journalCount == 0 {
			log.Printf("   ‚ùå Purchase %s (%.2f) has NO journal entries", 
				purchase.Code, purchase.TotalAmount)
		} else {
			log.Printf("   ‚úÖ Purchase %s (%.2f) has %d journal entries", 
				purchase.Code, purchase.TotalAmount, journalCount)
		}
	}

	return nil
}

func createMissingJournalEntries(db *gorm.DB) error {
	// Get approved purchases without journal entries
	var approvedPurchases []models.Purchase
	if err := db.Preload("Vendor").
		Where("status = ? AND approval_status = ?", 
			models.PurchaseStatusApproved, models.PurchaseApprovalApproved).
		Find(&approvedPurchases).Error; err != nil {
		return fmt.Errorf("failed to get approved purchases: %v", err)
	}

	for _, purchase := range approvedPurchases {
		// Check if already has journal entries
		var journalCount int64
		db.Model(&models.SSOTJournalEntry{}).
			Where("source_type = ? AND source_id = ?", models.SSOTSourceTypePurchase, purchase.ID).
			Count(&journalCount)

		if journalCount == 0 {
			log.Printf("   üèóÔ∏è Creating journal entries for purchase %s...", purchase.Code)
			if err := createPurchaseJournalEntry(db, &purchase); err != nil {
				log.Printf("   ‚ùå Failed to create journal for %s: %v", purchase.Code, err)
			} else {
				log.Printf("   ‚úÖ Created journal entries for %s", purchase.Code)
			}
		}
	}

	return nil
}

func createPurchaseJournalEntry(db *gorm.DB, purchase *models.Purchase) error {
	// Start transaction
	tx := db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Create journal entry
	entryNumber := fmt.Sprintf("PUR-%s", purchase.Code)
	
	// Find required accounts
	var inventoryAccount, payableAccount models.Account
	
	// Get inventory account
	if err := tx.Where("code = ? OR name ILIKE ?", "1301", "%Persediaan%").First(&inventoryAccount).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("inventory account not found: %v", err)
	}
	
	// Get payable account  
	if err := tx.Where("code = ? OR name ILIKE ?", "2101", "%Utang Usaha%").First(&payableAccount).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("payable account not found: %v", err)
	}

	// Create SSOT journal entry
	journalEntry := models.SSOTJournalEntry{
		EntryNumber:      entryNumber,
		SourceType:       models.SSOTSourceTypePurchase,
		SourceID:         &[]uint64{uint64(purchase.ID)}[0],
		SourceCode:       purchase.Code,
		EntryDate:        purchase.Date,
		Description:      fmt.Sprintf("Purchase from %s - %s", purchase.Vendor.Name, purchase.Code),
		Reference:        purchase.Code,
		Status:           models.SSOTStatusPosted,
		IsAutoGenerated:  true,
		CreatedBy:        uint64(purchase.UserID),
	}

	if err := tx.Create(&journalEntry).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create journal entry: %v", err)
	}

	// Create journal lines
	// 1. Debit Inventory (Asset increase)
	inventoryLine := models.SSOTJournalLine{
		JournalID:    journalEntry.ID,
		AccountID:    uint64(inventoryAccount.ID),
		LineNumber:   1,
		Description:  "Inventory purchase",
		DebitAmount:  decimal.NewFromFloat(purchase.SubtotalBeforeDiscount),
		CreditAmount: decimal.Zero,
	}

	// 2. Credit Accounts Payable (Liability increase)
	payableLine := models.SSOTJournalLine{
		JournalID:    journalEntry.ID,
		AccountID:    uint64(payableAccount.ID),
		LineNumber:   2,
		Description:  "Accounts payable",
		DebitAmount:  decimal.Zero,
		CreditAmount: decimal.NewFromFloat(purchase.TotalAmount),
	}

	if err := tx.Create(&inventoryLine).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create inventory line: %v", err)
	}

	if err := tx.Create(&payableLine).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create payable line: %v", err)
	}

	// Handle tax if exists
	if purchase.PPNAmount > 0 {
		var taxAccount models.Account
		if err := tx.Where("code = ? OR name ILIKE ?", "2102", "%Pajak%").First(&taxAccount).Error; err == nil {
			taxLine := models.SSOTJournalLine{
				JournalID:    journalEntry.ID,
				AccountID:    uint64(taxAccount.ID),
				LineNumber:   3,
				Description:  "PPN Tax",
				DebitAmount:  decimal.Zero,
				CreditAmount: decimal.NewFromFloat(purchase.PPNAmount),
			}
			tx.Create(&taxLine)
		}
	}

	// Update journal entry totals
	journalEntry.TotalDebit = decimal.NewFromFloat(purchase.SubtotalBeforeDiscount)
	journalEntry.TotalCredit = decimal.NewFromFloat(purchase.TotalAmount)
	tx.Save(&journalEntry)

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return fmt.Errorf("failed to commit transaction: %v", err)
	}

	return nil
}

func updateCOABalances(db *gorm.DB) error {
	log.Println("   üîÑ Recalculating COA balances from SSOT journal lines...")

	// Get all accounts
	var accounts []models.Account
	if err := db.Find(&accounts).Error; err != nil {
		return fmt.Errorf("failed to get accounts: %v", err)
	}

	for _, account := range accounts {
		// Calculate balance from SSOT journal lines
		var totalDebit, totalCredit float64

		// Sum debits
		var debitSum struct {
			Total float64
		}
		db.Raw(`
			SELECT COALESCE(SUM(debit_amount), 0) as total 
			FROM unified_journal_lines ujl
			JOIN unified_journal_ledger ujl2 ON ujl.journal_id = ujl2.id
			WHERE ujl.account_id = ? AND ujl2.status = 'POSTED'
		`, account.ID).Scan(&debitSum)
		totalDebit = debitSum.Total

		// Sum credits  
		var creditSum struct {
			Total float64
		}
		db.Raw(`
			SELECT COALESCE(SUM(credit_amount), 0) as total 
			FROM unified_journal_lines ujl
			JOIN unified_journal_ledger ujl2 ON ujl.journal_id = ujl2.id
			WHERE ujl.account_id = ? AND ujl2.status = 'POSTED'
		`, account.ID).Scan(&creditSum)
		totalCredit = creditSum.Total

		// Calculate new balance based on account type
		var newBalance float64
		normalBalance := getAccountNormalBalance(account.Type)

		if normalBalance == "DEBIT" {
			newBalance = totalDebit - totalCredit
		} else {
			newBalance = totalCredit - totalDebit
		}

		// Update account balance if changed
		if account.Balance != newBalance {
			log.Printf("   üí∞ Updating %s balance: %.2f ‚Üí %.2f", account.Name, account.Balance, newBalance)
			db.Model(&account).Update("balance", newBalance)
		}
	}

	return nil
}

func getAccountNormalBalance(accountType string) string {
	switch accountType {
	case "ASSET", "EXPENSE":
		return "DEBIT"
	case "LIABILITY", "EQUITY", "REVENUE":
		return "CREDIT"
	default:
		return "DEBIT"
	}
}

func verifyIntegration(db *gorm.DB) {
	log.Println("   üîç Verifying integration results...")

	// Check approved purchases
	var approvedCount int64
	db.Model(&models.Purchase{}).Where("status = ? AND approval_status = ?", 
		models.PurchaseStatusApproved, models.PurchaseApprovalApproved).Count(&approvedCount)
	log.Printf("   üìä Approved purchases: %d", approvedCount)

	// Check SSOT journal entries
	var journalCount int64
	db.Model(&models.SSOTJournalEntry{}).Where("source_type = ?", models.SSOTSourceTypePurchase).Count(&journalCount)
	log.Printf("   üìë Purchase journal entries: %d", journalCount)

	// Check accounts with non-zero balance
	var nonZeroBalances int64
	db.Model(&models.Account{}).Where("balance != 0").Count(&nonZeroBalances)
	log.Printf("   üí∞ Accounts with balance: %d", nonZeroBalances)

	// Show key account balances
	keyAccounts := []string{"1301", "2101", "1102"} // Inventory, Payable, Bank BCA
	for _, code := range keyAccounts {
		var account models.Account
		if err := db.Where("code = ?", code).First(&account).Error; err == nil {
			log.Printf("   üí≥ %s (%s): %.2f", account.Name, account.Code, account.Balance)
		}
	}

	if approvedCount > 0 && journalCount >= approvedCount {
		log.Println("   ‚úÖ Integration is working: All approved purchases have journal entries")
	} else {
		log.Println("   ‚ö†Ô∏è  Integration issue: Some approved purchases missing journal entries")
	}
}