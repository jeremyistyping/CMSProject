package services

import (
	"fmt"
	"log"
	"app-sistem-akuntansi/models"
	"gorm.io/gorm"
	"github.com/shopspring/decimal"
)

// UnifiedSalesJournalServiceFixed provides WORKING sales journal integration
type UnifiedSalesJournalServiceFixed struct {
	db              *gorm.DB
	accountResolver *AccountResolver
}

func NewUnifiedSalesJournalServiceFixed(db *gorm.DB) *UnifiedSalesJournalServiceFixed {
	return &UnifiedSalesJournalServiceFixed{
		db:              db,
		accountResolver: NewAccountResolver(db),
	}
}

// CreateSaleJournalEntry creates journal entries when sale is invoiced
func (s *UnifiedSalesJournalServiceFixed) CreateSaleJournalEntry(sale *models.Sale, userID uint) (*models.SSOTJournalEntry, error) {
	log.Printf("ðŸ§¾ Creating FIXED journal entry for sale %d (Status: %s)", sale.ID, sale.Status)

	// Only create journal entries for invoiced sales
	if sale.Status != models.SaleStatusInvoiced {
		return nil, fmt.Errorf("journal entries can only be created for invoiced sales, current status: %s", sale.Status)
	}

	// Get required accounts
	arAccount, err := s.getAccountByCode("1201") // Accounts Receivable
	if err != nil {
		return nil, fmt.Errorf("failed to find AR account: %v", err)
	}

	revenueAccount, err := s.getAccountByCode("4101") // Sales Revenue
	if err != nil {
		return nil, fmt.Errorf("failed to find revenue account: %v", err)
	}

	ppnAccount, err := s.getAccountByCode("2103") // PPN Keluaran
	if err != nil {
		log.Printf("Warning: Could not find PPN account: %v", err)
	}

	// Calculate amounts
	totalAmount := sale.TotalAmount
	ppnAmount := sale.PPN
	revenueAmount := totalAmount - ppnAmount

	// Create journal ledger entry
	sourceIDUint64 := uint64(sale.ID)
	entry := &models.SSOTJournalEntry{
		EntryNumber:     s.generateEntryNumber(sale.Code),
		SourceType:      "SALES",
		SourceID:        &sourceIDUint64,
		SourceCode:      sale.Code,
		EntryDate:       sale.Date,
		Description:     fmt.Sprintf("Sales Invoice %s", sale.InvoiceNumber),
		Reference:       sale.InvoiceNumber,
		TotalDebit:      decimal.NewFromFloat(totalAmount),
		TotalCredit:     decimal.NewFromFloat(totalAmount),
		Status:          "POSTED",
		IsBalanced:      true,
		IsAutoGenerated: true,
		CreatedBy:       uint64(userID),
	}

	// Create journal lines
	var lines []models.SSOTJournalLine

	// 1. DEBIT: Accounts Receivable (What customer owes us)
	lines = append(lines, models.SSOTJournalLine{
		AccountID:    uint64(arAccount.ID),
		LineNumber:   1,
		Description:  fmt.Sprintf("AR - Invoice %s", sale.InvoiceNumber),
		DebitAmount:  decimal.NewFromFloat(totalAmount),
		CreditAmount: decimal.NewFromFloat(0),
	})

	// 2. CREDIT: Sales Revenue (Income earned)
	lines = append(lines, models.SSOTJournalLine{
		AccountID:    uint64(revenueAccount.ID),
		LineNumber:   2,
		Description:  fmt.Sprintf("Sales Revenue - Invoice %s", sale.InvoiceNumber),
		DebitAmount:  decimal.NewFromFloat(0),
		CreditAmount: decimal.NewFromFloat(revenueAmount),
	})

	// 3. CREDIT: PPN Keluaran (if applicable)
	if ppnAmount > 0 && ppnAccount != nil {
		lines = append(lines, models.SSOTJournalLine{
			AccountID:    uint64(ppnAccount.ID),
			LineNumber:   3,
			Description:  fmt.Sprintf("PPN 11%% - Invoice %s", sale.InvoiceNumber),
			DebitAmount:  decimal.NewFromFloat(0),
			CreditAmount: decimal.NewFromFloat(ppnAmount),
		})
	}

	entry.Lines = lines

	// Save in transaction
	err = s.db.Transaction(func(tx *gorm.DB) error {
		// Save journal entry
		if err := tx.Create(entry).Error; err != nil {
			return fmt.Errorf("failed to create journal entry: %v", err)
		}

		// Update account balances
		return s.updateAccountBalances(tx, entry)
	})

	if err != nil {
		return nil, err
	}

	log.Printf("âœ… Created FIXED journal entry %d for sale %d", entry.ID, sale.ID)
	return entry, nil
}

// CreatePaymentJournalEntry creates journal entries when payment is received
func (s *UnifiedSalesJournalServiceFixed) CreatePaymentJournalEntry(payment *models.SalePayment, userID uint) (*models.SSOTJournalEntry, error) {
	log.Printf("ðŸ’° Creating FIXED payment journal entry for payment %d", payment.ID)

	// Get required accounts
	arAccount, err := s.getAccountByCode("1201") // Accounts Receivable
	if err != nil {
		return nil, fmt.Errorf("failed to find AR account: %v", err)
	}

	// Determine bank account based on payment method
	var bankAccount *models.Account
	switch payment.PaymentMethod {
	case "BANK_BCA":
		bankAccount, err = s.getAccountByCode("1102")
	case "BANK_MANDIRI":
		bankAccount, err = s.getAccountByCode("1103")
	case "CASH":
		bankAccount, err = s.getAccountByCode("1101")
	default:
		bankAccount, err = s.getAccountByCode("1104") // Default to UOB
	}
	
	if err != nil {
		return nil, fmt.Errorf("failed to find bank account for method %s: %v", payment.PaymentMethod, err)
	}

	// Create journal entry
	paymentIDUint64 := uint64(payment.ID)
	entry := &models.SSOTJournalEntry{
		EntryNumber:     s.generatePaymentEntryNumber(payment.ID),
		SourceType:      "SALES_PAYMENT",
		SourceID:        &paymentIDUint64,
		EntryDate:       payment.PaymentDate,
		Description:     fmt.Sprintf("Customer Payment - Amount: %.0f", payment.Amount),
		Reference:       payment.Reference,
		TotalDebit:      decimal.NewFromFloat(payment.Amount),
		TotalCredit:     decimal.NewFromFloat(payment.Amount),
		Status:          "POSTED",
		IsBalanced:      true,
		IsAutoGenerated: true,
		CreatedBy:       uint64(userID),
	}

	// Create journal lines
	var lines []models.SSOTJournalLine

	// 1. DEBIT: Bank/Cash (Cash received)
	lines = append(lines, models.SSOTJournalLine{
		AccountID:    uint64(bankAccount.ID),
		LineNumber:   1,
		Description:  fmt.Sprintf("Payment received - %s", payment.PaymentMethod),
		DebitAmount:  decimal.NewFromFloat(payment.Amount),
		CreditAmount: decimal.NewFromFloat(0),
	})

	// 2. CREDIT: Accounts Receivable (Reduce customer debt)
	lines = append(lines, models.SSOTJournalLine{
		AccountID:    uint64(arAccount.ID),
		LineNumber:   2,
		Description:  "AR reduction - Payment received",
		DebitAmount:  decimal.NewFromFloat(0),
		CreditAmount: decimal.NewFromFloat(payment.Amount),
	})

	entry.Lines = lines

	// Save in transaction
	err = s.db.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(entry).Error; err != nil {
			return fmt.Errorf("failed to create payment journal entry: %v", err)
		}
		return s.updateAccountBalances(tx, entry)
	})

	if err != nil {
		return nil, err
	}

	log.Printf("âœ… Created FIXED payment journal entry %d for payment %d", entry.ID, payment.ID)
	return entry, nil
}

// Helper methods
func (s *UnifiedSalesJournalServiceFixed) getAccountByCode(code string) (*models.Account, error) {
	var account models.Account
	err := s.db.Where("code = ?", code).First(&account).Error
	if err != nil {
		return nil, fmt.Errorf("account %s not found: %v", code, err)
	}
	return &account, nil
}

func (s *UnifiedSalesJournalServiceFixed) generateEntryNumber(saleCode string) string {
	return fmt.Sprintf("JRN-SALES-%s", saleCode)
}

func (s *UnifiedSalesJournalServiceFixed) generatePaymentEntryNumber(paymentID uint) string {
	return fmt.Sprintf("JRN-PAY-%d", paymentID)
}

func (s *UnifiedSalesJournalServiceFixed) updateAccountBalances(tx *gorm.DB, entry *models.SSOTJournalEntry) error {
	// Update account balances based on journal lines
	for _, line := range entry.Lines {
		var account models.Account
		if err := tx.First(&account, line.AccountID).Error; err != nil {
			return fmt.Errorf("failed to find account %d: %v", line.AccountID, err)
		}

		// Calculate balance change based on account type
		var balanceChange float64
		if account.Type == models.AccountTypeAsset || account.Type == models.AccountTypeExpense {
			// Assets and Expenses increase with debits, decrease with credits
			balanceChange = line.DebitAmount.InexactFloat64() - line.CreditAmount.InexactFloat64()
		} else {
			// Liabilities, Equity, and Revenue increase with credits, decrease with debits  
			balanceChange = line.CreditAmount.InexactFloat64() - line.DebitAmount.InexactFloat64()
		}

		// Update account balance
		newBalance := account.Balance + balanceChange
		if err := tx.Model(&account).Update("balance", newBalance).Error; err != nil {
			return fmt.Errorf("failed to update account %s balance: %v", account.Code, err)
		}

		log.Printf("ðŸ“Š Updated account %s balance: %.0f -> %.0f (change: %+.0f)", 
			account.Code, account.Balance, newBalance, balanceChange)
	}

	return nil
}
