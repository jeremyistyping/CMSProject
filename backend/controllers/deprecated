package controllers

import (
	"net/http"
	"strconv"
	"app-sistem-akuntansi/models"
	"app-sistem-akuntansi/services"
	"github.com/gin-gonic/gin"
)

type InvoiceController struct {
	invoiceService *services.InvoiceServiceFull
}

func NewInvoiceController(invoiceService *services.InvoiceServiceFull) *InvoiceController {
	return &InvoiceController{
		invoiceService: invoiceService,
	}
}

// GetInvoices handles GET /api/v1/invoices
func (ic *InvoiceController) GetInvoices(c *gin.Context) {
	// Parse query parameters
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))
	status := c.Query("status")
	customerID := c.Query("customer_id")
	startDate := c.Query("start_date")
	endDate := c.Query("end_date")
	search := c.Query("search")

	filter := models.InvoiceFilter{
		Status:     status,
		CustomerID: customerID,
		StartDate:  startDate,
		EndDate:    endDate,
		Search:     search,
		Page:       page,
		Limit:      limit,
	}

	result, err := ic.invoiceService.GetInvoices(filter)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to retrieve invoices",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": result,
	})
}

// GetInvoice handles GET /api/v1/invoices/:id
func (ic *InvoiceController) GetInvoice(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid invoice ID",
		})
		return
	}

	invoice, err := ic.invoiceService.GetInvoiceByID(uint(id))
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Invoice not found",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": invoice,
	})
}

// CreateInvoice handles POST /api/v1/invoices
func (ic *InvoiceController) CreateInvoice(c *gin.Context) {
	var request models.InvoiceCreateRequest
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request format",
			"details": err.Error(),
		})
		return
	}

	userID := c.MustGet("user_id").(uint)

	invoice, err := ic.invoiceService.CreateInvoice(request, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create invoice",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"success": true,
		"message": "Invoice created successfully",
		"data": invoice,
	})
}

// UpdateInvoice handles PUT /api/v1/invoices/:id
func (ic *InvoiceController) UpdateInvoice(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid invoice ID",
		})
		return
	}

	var request models.InvoiceUpdateRequest
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request format",
			"details": err.Error(),
		})
		return
	}

	userID := c.MustGet("user_id").(uint)

	invoice, err := ic.invoiceService.UpdateInvoice(uint(id), request, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to update invoice",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Invoice updated successfully",
		"data": invoice,
	})
}

// DeleteInvoice handles DELETE /api/v1/invoices/:id
func (ic *InvoiceController) DeleteInvoice(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid invoice ID",
		})
		return
	}

	err = ic.invoiceService.DeleteInvoice(uint(id))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to delete invoice",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Invoice deleted successfully",
	})
}

// GenerateInvoiceCode handles POST /api/v1/invoices/generate-code
func (ic *InvoiceController) GenerateInvoiceCode(c *gin.Context) {
	code, err := ic.invoiceService.GenerateInvoiceCode()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to generate invoice code",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"code": code,
		},
	})
}

// FormatCurrency handles POST /api/v1/invoices/format-currency
func (ic *InvoiceController) FormatCurrency(c *gin.Context) {
	var request struct {
		Amount float64 `json:"amount" binding:"required"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request format",
			"details": err.Error(),
		})
		return
	}

	formatted, err := ic.invoiceService.FormatCurrency(request.Amount)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to format currency",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"formatted": formatted,
		},
	})
}