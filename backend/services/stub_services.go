package services

import (
	"fmt"
	"log"
	"time"
	"app-sistem-akuntansi/models"
	"github.com/shopspring/decimal"
	"gorm.io/gorm"
)

// STUB SERVICES - These replace the deleted problematic services
// They implement minimal functionality to avoid breaking dependencies
// but they properly validate status before posting

// UnifiedJournalService STUB - prevents auto-posting
type UnifiedJournalService struct {
	db *gorm.DB
}

func NewUnifiedJournalService(db *gorm.DB) *UnifiedJournalService {
	return &UnifiedJournalService{db: db}
}

// CreateJournalEntry creates a unified journal entry with its lines.
// This implementation is intentionally minimal but functional, enabling
// purchases to post journals while keeping other auto-posts disabled elsewhere.
func (s *UnifiedJournalService) CreateJournalEntry(entry interface{}) (*models.SSOTJournalEntry, error) {
	req, ok := entry.(*JournalEntryRequest)
	if !ok || req == nil {
		return nil, fmt.Errorf("invalid journal entry request")
	}

	if len(req.Lines) < 2 {
		return nil, fmt.Errorf("at least two journal lines are required")
	}

	// Calculate totals and ensure balance using decimal
	var totalDebit, totalCredit decimal.Decimal
	for _, l := range req.Lines {
		if l.DebitAmount.IsZero() && l.CreditAmount.IsZero() {
			return nil, fmt.Errorf("journal line must have either debit or credit amount")
		}
		totalDebit = totalDebit.Add(l.DebitAmount)
		totalCredit = totalCredit.Add(l.CreditAmount)
	}

	isBalanced := totalDebit.Equal(totalCredit) && totalDebit.GreaterThan(decimal.Zero)
	if !isBalanced {
		return nil, fmt.Errorf("journal entry is not balanced")
	}

	status := models.SSOTStatusDraft
	var postedAt *time.Time
	var postedBy *uint64
	if req.AutoPost {
		status = models.SSOTStatusPosted
		now := time.Now()
		postedAt = &now
		uid := req.CreatedBy
		postedBy = &uid
	}

	entryModel := &models.SSOTJournalEntry{
		SourceType:     req.SourceType,
		SourceID:       &req.SourceID,
		EntryDate:      req.EntryDate,
		Description:    req.Description,
		Reference:      req.Reference,
		TotalDebit:     totalDebit,
		TotalCredit:    totalCredit,
		Status:         status,
		IsBalanced:     true,
		IsAutoGenerated: true,
		PostedAt:       postedAt,
		PostedBy:       postedBy,
		CreatedBy:      req.CreatedBy,
	}

	// Persist with lines in a transaction
	if err := s.db.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(entryModel).Error; err != nil {
			return fmt.Errorf("failed to create journal entry: %w", err)
		}
		// Create lines with proper numbering
		for i, l := range req.Lines {
			line := &models.SSOTJournalLine{
				JournalID:   entryModel.ID,
				AccountID:   l.AccountID,
				LineNumber:  i + 1,
				Description: l.Description,
				DebitAmount: l.DebitAmount,
				CreditAmount:l.CreditAmount,
			}
			if err := tx.Create(line).Error; err != nil {
				return fmt.Errorf("failed to create journal line: %w", err)
			}
		}
		
		// âœ… UPDATE ACCOUNT BALANCES if journal is auto-posted
		if req.AutoPost && status == models.SSOTStatusPosted {
			log.Printf("ðŸ”„ Updating account balances for posted journal entry ID=%d", entryModel.ID)
			
			for _, line := range req.Lines {
				// Get account to determine normal balance type
				var account models.Account
				if err := tx.First(&account, line.AccountID).Error; err != nil {
					log.Printf("âš ï¸ Warning: Failed to get account %d for balance update: %v", line.AccountID, err)
					continue
				}
				
				// Calculate balance change based on normal balance
				// Debit increases Asset/Expense, Credit increases Liability/Equity/Revenue
				var balanceChange float64
				if account.Type == models.AccountTypeAsset || account.Type == models.AccountTypeExpense {
					// Normal balance = DEBIT
					// Debit increases (+), Credit decreases (-)
					balanceChange = line.DebitAmount.InexactFloat64() - line.CreditAmount.InexactFloat64()
				} else {
					// Normal balance = CREDIT (Liability, Equity, Revenue)
					// Credit increases (+), Debit decreases (-)
					balanceChange = line.CreditAmount.InexactFloat64() - line.DebitAmount.InexactFloat64()
				}
				
				// Update account balance
				if err := tx.Model(&models.Account{}).
					Where("id = ?", line.AccountID).
					UpdateColumn("balance", gorm.Expr("balance + ?", balanceChange)).Error; err != nil {
					return fmt.Errorf("failed to update account %d balance: %w", line.AccountID, err)
				}
				
				log.Printf("âœ… Updated account %d (%s) balance: %+.2f", line.AccountID, account.Code, balanceChange)
			}
		}
		
		return nil
	}); err != nil {
		return nil, err
	}

	// Reload with lines and account details
	var saved models.SSOTJournalEntry
	if err := s.db.
		Preload("Lines").
		Preload("Lines.Account").
		First(&saved, entryModel.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to reload journal entry: %w", err)
	}

	return &saved, nil
}

// CashBankSSOTJournalAdapter STUB
type CashBankSSOTJournalAdapter struct {
	db *gorm.DB
}

func NewCashBankSSOTJournalAdapter(db *gorm.DB) *CashBankSSOTJournalAdapter {
	return &CashBankSSOTJournalAdapter{db: db}
}

func (s *CashBankSSOTJournalAdapter) CreateJournalEntry(transaction interface{}) error {
	return fmt.Errorf("cashbank journal adapter has been disabled to prevent auto-posting")
}

func (s *CashBankSSOTJournalAdapter) CreateTransferJournalEntryWithTx(tx *gorm.DB, sourceAccount, destAccount *models.CashBank, sourceTx *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// âœ… CASH & BANK auto-posting is ALLOWED (different from sales)
	return s.createActualTransferJournalEntry(tx, sourceAccount, destAccount, sourceTx, request)
}

func (s *CashBankSSOTJournalAdapter) CreateDepositJournalEntryWithTx(tx *gorm.DB, account *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*CashBankJournalResult, error) {
	// âœ… CASH & BANK auto-posting is ALLOWED (different from sales)
	// Create a proper SSOT journal entry for cash/bank deposits
	return s.createActualDepositJournalEntry(tx, account, transaction, request)
}

func (s *CashBankSSOTJournalAdapter) CreateWithdrawalJournalEntryWithTx(tx *gorm.DB, account *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// âœ… CASH & BANK auto-posting is ALLOWED (different from sales)
	return s.createActualWithdrawalJournalEntry(tx, account, transaction, request)
}

func (s *CashBankSSOTJournalAdapter) CreateOpeningBalanceJournalEntryWithTx(tx *gorm.DB, cashBank *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// âœ… CASH & BANK auto-posting is ALLOWED (different from sales)
	return s.createActualOpeningBalanceJournalEntry(tx, cashBank, transaction, request)
}

// PaymentJournalFactory STUB  
type PaymentJournalFactory struct {
	db *gorm.DB
}

func NewPaymentJournalFactory(db *gorm.DB) *PaymentJournalFactory {
	return &PaymentJournalFactory{db: db}
}

type PaymentJournalResult struct {
	Success         bool
	Error          error
	Message         string
	JournalEntry   *models.SSOTJournalEntry
	AccountUpdates []AccountBalanceUpdate
}

func (s *PaymentJournalFactory) CreatePaymentJournal(payment interface{}) (*PaymentJournalResult, error) {
	return &PaymentJournalResult{
		Success: false,
		Error:   fmt.Errorf("payment journal factory has been disabled to prevent auto-posting"),
	}, nil
}

func (s *PaymentJournalFactory) CreateReceivablePaymentJournal(payment interface{}, contact interface{}, cashBank interface{}) (*PaymentJournalResult, error) {
	return &PaymentJournalResult{
		Success: false,
		Error:   fmt.Errorf("receivable payment journal has been disabled to prevent auto-posting"),
	}, nil
}

func (s *PaymentJournalFactory) CreatePayablePaymentJournal(payment interface{}, contact interface{}, cashBank interface{}) (*PaymentJournalResult, error) {
	return &PaymentJournalResult{
		Success: false,
		Error:   fmt.Errorf("payable payment journal has been disabled to prevent auto-posting"),
	}, nil
}

func (s *PaymentJournalFactory) PreviewPaymentJournalEntry(request *PaymentJournalRequest) (*PaymentJournalResult, error) {
	return &PaymentJournalResult{
		Success: false,
		Error:   fmt.Errorf("payment journal preview has been disabled to prevent auto-posting"),
	}, nil
}

func (s *PaymentJournalFactory) ReversePaymentJournal(paymentID uint64, reason string, userID uint64) (*PaymentJournalResult, error) {
	return &PaymentJournalResult{
		Success: false,
		Error:   fmt.Errorf("payment journal reversal has been disabled to prevent auto-posting"),
	}, nil
}


// SSOTSalesJournalService STUB - validates status before allowing posting
type SSOTSalesJournalService struct {
	db *gorm.DB
}

func NewSSOTSalesJournalService(db *gorm.DB) *SSOTSalesJournalService {
	return &SSOTSalesJournalService{db: db}
}

func (s *SSOTSalesJournalService) CreateSaleJournalEntry(sale *models.Sale, userID uint) (*models.SSOTJournalEntry, error) {
	// CRITICAL: Only allow for INVOICED sales
	if sale.Status != models.SaleStatusInvoiced && sale.Status != models.SaleStatusPaid {
		return nil, fmt.Errorf("journal entries can only be created for INVOICED or PAID sales, current status: %s", sale.Status)
	}
	
	// Create a simple journal entry for invoiced sales
	journal := &models.SSOTJournalEntry{
		EntryNumber:   fmt.Sprintf("SALE-%d", time.Now().Unix()),
		EntryDate:     time.Now(),
		Description:   fmt.Sprintf("Sale journal entry for sale ID %d", sale.ID),
		Reference:     sale.Code,
		Status:        "POSTED",
		TotalDebit:    decimal.NewFromFloat(sale.TotalAmount),
		TotalCredit:   decimal.NewFromFloat(sale.TotalAmount),
		CreatedBy:     uint64(userID),
		CreatedAt:     time.Now(),
	}
	
	if err := s.db.Create(journal).Error; err != nil {
		return nil, fmt.Errorf("failed to create sale journal entry: %v", err)
	}
	
	return journal, nil
}

// UnifiedSalesJournalService STUB - disabled to prevent auto-posting
type UnifiedSalesJournalService struct {
	db *gorm.DB
}

func NewUnifiedSalesJournalService(db *gorm.DB) *UnifiedSalesJournalService {
	return &UnifiedSalesJournalService{db: db}
}

func (s *UnifiedSalesJournalService) CreateSaleJournalEntry(sale interface{}, userID uint) error {
	return fmt.Errorf("unified sales journal service has been disabled to prevent auto-posting")
}

// UnifiedSalesPaymentService STUB - disabled to prevent auto-posting
type UnifiedSalesPaymentService struct {
	db *gorm.DB
}

func NewUnifiedSalesPaymentService(db *gorm.DB) *UnifiedSalesPaymentService {
	return &UnifiedSalesPaymentService{db: db}
}

func (s *UnifiedSalesPaymentService) CreatePaymentJournalEntry(payment interface{}, userID uint) error {
	return fmt.Errorf("unified sales payment service has been disabled to prevent auto-posting")
}

func (s *UnifiedSalesPaymentService) ValidatePaymentRequest(request interface{}) error {
	return fmt.Errorf("payment validation has been disabled")
}

func (s *UnifiedSalesPaymentService) CreateSalesPayment(saleID uint, request interface{}, userID uint) (*models.SalePayment, error) {
	return nil, fmt.Errorf("sales payment creation has been disabled to prevent auto-posting")
}

// Missing types needed by the services

// JournalServiceInterface - interface for journal services
type JournalServiceInterface interface {
	CreateSaleJournalEntries(sale *models.Sale, userID uint) error
	CreatePaymentJournalEntries(payment *models.SalePayment, userID uint) error
	CreateSaleReversalJournalEntries(sale *models.Sale, userID uint, reason string) error
}

// PDFServiceInterface - interface for PDF generation services
type PDFServiceInterface interface {
	GeneratePurchaseOrderPDF(purchase *models.Purchase) ([]byte, error)
	GeneratePurchaseReceiptPDF(receipt *models.PurchaseReceipt) ([]byte, error)
	GenerateInvoicePDF(invoice interface{}) ([]byte, error)
	GeneratePaymentReportPDF(data interface{}) ([]byte, error)
	GeneratePaymentDetailPDF(payment interface{}) ([]byte, error)
	GenerateReceiptPDF(receipt interface{}) ([]byte, error)
	GenerateReceiptPDFWithUser(receipt interface{}, userID uint) ([]byte, error)
	GenerateAllReceiptsPDF(receipts interface{}) ([]byte, error)

	// Additional report exports used by controllers
	GenerateSalesReportPDF(sales []models.Sale, startDate, endDate string) ([]byte, error)
	GenerateTrialBalancePDF(trialBalanceData interface{}, asOfDate string) ([]byte, error)
	GenerateBalanceSheetPDF(balanceSheetData interface{}, asOfDate string) ([]byte, error)
	GenerateGeneralLedgerPDF(ledgerData interface{}, accountInfo string, startDate, endDate string) ([]byte, error)
	GenerateSSOTProfitLossPDF(ssotData interface{}) ([]byte, error)
	GenerateJournalAnalysisPDF(journalData interface{}, startDate, endDate string) ([]byte, error)
	GenerateSalesSummaryPDF(summary interface{}) ([]byte, error)
	GenerateCustomerHistoryPDF(historyData interface{}) ([]byte, error)
	GenerateVendorHistoryPDF(historyData interface{}) ([]byte, error)
	GenerateCustomerHistoryCSV(historyData interface{}) ([]byte, error)
	GenerateVendorHistoryCSV(historyData interface{}) ([]byte, error)
	// Language returns current language based on settings
	Language() string
}

type CashBankJournalRequest struct {
	TransactionType  string
	CashBankID      uint64
	Amount          decimal.Decimal
	Date            time.Time
	Reference       string
	Description     string
	Notes           string
	FromCashBankID  *uint64
	ToCashBankID    *uint64
	CounterAccountID *uint64 // For deposit/withdrawal equity/expense mapping
	CreatedBy       uint64
}

type CashBankJournalResult struct {
	JournalEntry *models.SSOTJournalEntry
	Success      bool
	Error        error
}

type AccountBalanceUpdate struct {
	AccountID   uint64
	OldBalance  decimal.Decimal
	NewBalance  decimal.Decimal
	Change      decimal.Decimal
	ChangeType  string
}

type PaymentJournalRequest struct {
	PaymentID     uint64
	ContactID     uint64
	CashBankID    uint64
	Amount        decimal.Decimal
	Date          time.Time
	Method        string
	Reference     string
	Description   string
	Notes         string
	ContactType   string
	ContactName   string
	CreatedBy     uint64
}

// ACTUAL CASH & BANK JOURNAL IMPLEMENTATIONS
// These are enabled because cash/bank transactions should auto-post

func (s *CashBankSSOTJournalAdapter) createActualDepositJournalEntry(tx *gorm.DB, account *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*CashBankJournalResult, error) {
	// Create SSOT journal entry for deposit and proper lines (Debit Cash/Bank, Credit Equity)
	// Insert as DRAFT first to avoid trigger validation before lines are created
	journal := &models.SSOTJournalEntry{
		EntryNumber:   fmt.Sprintf("DEP-%d", time.Now().Unix()),
		EntryDate:     request.Date,
		Description:   fmt.Sprintf("Deposit to %s: %s", account.Name, request.Description),
		Reference:     request.Reference,
		Status:        "DRAFT",
		TotalDebit:    request.Amount,
		TotalCredit:   request.Amount,
		CreatedBy:     request.CreatedBy,
		CreatedAt:     time.Now(),
	}
	if err := tx.Create(journal).Error; err != nil {
		return nil, fmt.Errorf("failed to create deposit journal entry: %v", err)
	}
	// Determine credit (equity) account
	var creditAccountID uint64
	if request.CounterAccountID != nil && *request.CounterAccountID > 0 {
		creditAccountID = *request.CounterAccountID
	} else {
		// Fallback to owner's equity 3101 or first EQUITY account
		if id, err := findDefaultEquityAccountID(tx); err == nil {
			creditAccountID = id
		} else {
			return nil, fmt.Errorf("failed to resolve equity account: %v", err)
		}
	}
	// Create lines
	debitLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   uint64(account.AccountID),
		LineNumber:  1,
		Description: fmt.Sprintf("Deposit to %s", account.Name),
		DebitAmount: request.Amount,
		CreditAmount: decimal.Zero,
	}
	creditLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   creditAccountID,
		LineNumber:  2,
		Description: "Equity/Capital Deposit",
		DebitAmount: decimal.Zero,
		CreditAmount: request.Amount,
	}
	if err := tx.Create(debitLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create deposit debit line: %v", err)
	}
	if err := tx.Create(creditLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create deposit credit line: %v", err)
	}
	// Now update status to POSTED after lines are created
	if err := tx.Model(journal).Update("status", "POSTED").Error; err != nil {
		return nil, fmt.Errorf("failed to post deposit journal entry: %v", err)
	}
	journal.Status = "POSTED" // Update in-memory object
	return &CashBankJournalResult{JournalEntry: journal, Success: true}, nil
}

func (s *CashBankSSOTJournalAdapter) createActualWithdrawalJournalEntry(tx *gorm.DB, account *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// Create SSOT journal entry for withdrawal and proper lines (Debit expense/target, Credit Cash/Bank)
	// Insert as DRAFT first to avoid trigger validation before lines are created
	journal := &models.SSOTJournalEntry{
		EntryNumber:   fmt.Sprintf("WIT-%d", time.Now().Unix()),
		EntryDate:     request.Date,
		Description:   fmt.Sprintf("Withdrawal from %s: %s", account.Name, request.Description),
		Reference:     request.Reference,
		Status:        "DRAFT",
		TotalDebit:    request.Amount,
		TotalCredit:   request.Amount,
		CreatedBy:     request.CreatedBy,
		CreatedAt:     time.Now(),
	}
	if err := tx.Create(journal).Error; err != nil {
		return nil, fmt.Errorf("failed to create withdrawal journal entry: %v", err)
	}
	// Determine debit account (target/expense)
	var debitAccountID uint64
	if request.CounterAccountID != nil && *request.CounterAccountID > 0 {
		debitAccountID = *request.CounterAccountID
	} else {
		if id, err := findDefaultExpenseAccountID(tx); err == nil {
			debitAccountID = id
		} else {
			return nil, fmt.Errorf("failed to resolve expense account: %v", err)
		}
	}
	debitLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   debitAccountID,
		LineNumber:  1,
		Description: "Withdrawal Expense",
		DebitAmount: request.Amount,
		CreditAmount: decimal.Zero,
	}
	creditLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   uint64(account.AccountID),
		LineNumber:  2,
		Description: fmt.Sprintf("Cash/Bank %s", account.Name),
		DebitAmount: decimal.Zero,
		CreditAmount: request.Amount,
	}
	if err := tx.Create(debitLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create withdrawal debit line: %v", err)
	}
	if err := tx.Create(creditLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create withdrawal credit line: %v", err)
	}
	// Now update status to POSTED after lines are created
	if err := tx.Model(journal).Update("status", "POSTED").Error; err != nil {
		return nil, fmt.Errorf("failed to post withdrawal journal entry: %v", err)
	}
	journal.Status = "POSTED" // Update in-memory object
	return journal, nil
}

func (s *CashBankSSOTJournalAdapter) createActualTransferJournalEntry(tx *gorm.DB, sourceAccount, destAccount *models.CashBank, sourceTx *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// Create SSOT journal entry for transfer and lines (Credit source cash/bank, Debit destination cash/bank)
	// Insert as DRAFT first to avoid trigger validation before lines are created
	journal := &models.SSOTJournalEntry{
		EntryNumber:   fmt.Sprintf("TRF-%d", time.Now().Unix()),
		EntryDate:     request.Date,
		Description:   fmt.Sprintf("Transfer from %s to %s: %s", sourceAccount.Name, destAccount.Name, request.Description),
		Reference:     request.Reference,
		Status:        "DRAFT",
		TotalDebit:    request.Amount,
		TotalCredit:   request.Amount,
		CreatedBy:     request.CreatedBy,
		CreatedAt:     time.Now(),
	}
	if err := tx.Create(journal).Error; err != nil {
		return nil, fmt.Errorf("failed to create transfer journal entry: %v", err)
	}
	debitLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   uint64(destAccount.AccountID),
		LineNumber:  1,
		Description: fmt.Sprintf("Transfer in to %s", destAccount.Name),
		DebitAmount: request.Amount,
		CreditAmount: decimal.Zero,
	}
	creditLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   uint64(sourceAccount.AccountID),
		LineNumber:  2,
		Description: fmt.Sprintf("Transfer out from %s", sourceAccount.Name),
		DebitAmount: decimal.Zero,
		CreditAmount: request.Amount,
	}
	if err := tx.Create(debitLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create transfer debit line: %v", err)
	}
	if err := tx.Create(creditLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create transfer credit line: %v", err)
	}
	// Now update status to POSTED after lines are created
	if err := tx.Model(journal).Update("status", "POSTED").Error; err != nil {
		return nil, fmt.Errorf("failed to post transfer journal entry: %v", err)
	}
	journal.Status = "POSTED" // Update in-memory object
	return journal, nil
}

func (s *CashBankSSOTJournalAdapter) createActualOpeningBalanceJournalEntry(tx *gorm.DB, cashBank *models.CashBank, transaction *models.CashBankTransaction, request *CashBankJournalRequest) (*models.SSOTJournalEntry, error) {
	// Create SSOT journal entry for opening balance and lines (Debit Cash/Bank, Credit Equity)
	// Insert as DRAFT first to avoid trigger validation before lines are created
	journal := &models.SSOTJournalEntry{
		EntryNumber:   fmt.Sprintf("OPB-%d", time.Now().Unix()),
		EntryDate:     request.Date,
		Description:   fmt.Sprintf("Opening balance for %s: %s", cashBank.Name, request.Description),
		Reference:     request.Reference,
		Status:        "DRAFT",
		TotalDebit:    request.Amount,
		TotalCredit:   request.Amount,
		CreatedBy:     request.CreatedBy,
		CreatedAt:     time.Now(),
	}
	if err := tx.Create(journal).Error; err != nil {
		return nil, fmt.Errorf("failed to create opening balance journal entry: %v", err)
	}
	// Equity credit
	var equityID uint64
	if request.CounterAccountID != nil && *request.CounterAccountID > 0 {
		equityID = *request.CounterAccountID
	} else {
		if id, err := findDefaultEquityAccountID(tx); err == nil {
			equityID = id
		} else {
			return nil, fmt.Errorf("failed to resolve equity account: %v", err)
		}
	}
	debitLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   uint64(cashBank.AccountID),
		LineNumber:  1,
		Description: "Opening Balance",
		DebitAmount: request.Amount,
		CreditAmount: decimal.Zero,
	}
	creditLine := &models.SSOTJournalLine{
		JournalID:   journal.ID,
		AccountID:   equityID,
		LineNumber:  2,
		Description: "Opening Balance Equity",
		DebitAmount: decimal.Zero,
		CreditAmount: request.Amount,
	}
	if err := tx.Create(debitLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create opening balance debit line: %v", err)
	}
	if err := tx.Create(creditLine).Error; err != nil {
		return nil, fmt.Errorf("failed to create opening balance credit line: %v", err)
	}
	
	// Now update status to POSTED after lines are created
	if err := tx.Model(journal).Update("status", "POSTED").Error; err != nil {
		return nil, fmt.Errorf("failed to post opening balance journal entry: %v", err)
	}
	journal.Status = "POSTED" // Update in-memory object
	
	// âœ… FIX: Update accounts.balance since journal is POSTED
	// Update Cash/Bank Account (Debit = increase for Asset)
	if err := tx.Model(&models.Account{}).
		Where("id = ?", cashBank.AccountID).
		UpdateColumn("balance", gorm.Expr("balance + ?", request.Amount.InexactFloat64())).Error; err != nil {
		return nil, fmt.Errorf("failed to update cash/bank account balance: %v", err)
	}
	
	// Update Equity Account (Credit = increase for Equity)
	if err := tx.Model(&models.Account{}).
		Where("id = ?", equityID).
		UpdateColumn("balance", gorm.Expr("balance + ?", request.Amount.InexactFloat64())).Error; err != nil {
		return nil, fmt.Errorf("failed to update equity account balance: %v", err)
	}
	
	log.Printf("âœ… Updated accounts.balance: Cash/Bank Account %d +%.2f, Equity Account %d +%.2f", 
		cashBank.AccountID, request.Amount.InexactFloat64(), equityID, request.Amount.InexactFloat64())
	
	return journal, nil
}

// Stub for UnifiedJournalService methods needed by enhanced_payment_service
func (s *UnifiedJournalService) GetJournalEntry(entryID uint64) (*models.SSOTJournalEntry, error) {
	var entry models.SSOTJournalEntry
	if err := s.db.
		Preload("Lines").
		Preload("Lines.Account").
		First(&entry, entryID).Error; err != nil {
		return nil, fmt.Errorf("journal entry not found: %w", err)
	}
	return &entry, nil
}

func (s *UnifiedJournalService) CreateJournalEntryWithTx(tx *gorm.DB, request *JournalEntryRequest) (*models.SSOTJournalEntry, error) {
	if tx == nil {
		return s.CreateJournalEntry(request)
	}
	// Reuse logic, but use provided tx
	if request == nil {
		return nil, fmt.Errorf("invalid journal entry request")
	}

	if len(request.Lines) < 2 {
		return nil, fmt.Errorf("at least two journal lines are required")
	}

	var totalDebit, totalCredit decimal.Decimal
	for _, l := range request.Lines {
		if l.DebitAmount.IsZero() && l.CreditAmount.IsZero() {
			return nil, fmt.Errorf("journal line must have either debit or credit amount")
		}
		totalDebit = totalDebit.Add(l.DebitAmount)
		totalCredit = totalCredit.Add(l.CreditAmount)
	}
	if !totalDebit.Equal(totalCredit) || totalDebit.LessThanOrEqual(decimal.Zero) {
		return nil, fmt.Errorf("journal entry is not balanced")
	}

	status := models.SSOTStatusDraft
	var postedAt *time.Time
	var postedBy *uint64
	if request.AutoPost {
		status = models.SSOTStatusPosted
		now := time.Now()
		postedAt = &now
		uid := request.CreatedBy
		postedBy = &uid
	}

	entryModel := &models.SSOTJournalEntry{
		SourceType:     request.SourceType,
		SourceID:       &request.SourceID,
		EntryDate:      request.EntryDate,
		Description:    request.Description,
		Reference:      request.Reference,
		TotalDebit:     totalDebit,
		TotalCredit:    totalCredit,
		Status:         status,
		IsBalanced:     true,
		IsAutoGenerated: true,
		PostedAt:       postedAt,
		PostedBy:       postedBy,
		CreatedBy:      request.CreatedBy,
	}
	if err := tx.Create(entryModel).Error; err != nil {
		return nil, fmt.Errorf("failed to create journal entry: %w", err)
	}
	for i, l := range request.Lines {
		line := &models.SSOTJournalLine{
			JournalID:   entryModel.ID,
			AccountID:   l.AccountID,
			LineNumber:  i + 1,
			Description: l.Description,
			DebitAmount: l.DebitAmount,
			CreditAmount:l.CreditAmount,
		}
		if err := tx.Create(line).Error; err != nil {
			return nil, fmt.Errorf("failed to create journal line: %w", err)
		}
	}
	
	// âœ… UPDATE ACCOUNT BALANCES if journal is auto-posted
	if request.AutoPost && status == models.SSOTStatusPosted {
		log.Printf("ðŸ”„ Updating account balances for posted journal entry ID=%d", entryModel.ID)
		
		for _, line := range request.Lines {
			// Get account to determine normal balance type
			var account models.Account
			if err := tx.First(&account, line.AccountID).Error; err != nil {
				log.Printf("âš ï¸ Warning: Failed to get account %d for balance update: %v", line.AccountID, err)
				continue
			}
			
			// Calculate balance change based on normal balance
			// Debit increases Asset/Expense, Credit increases Liability/Equity/Revenue
			var balanceChange float64
			if account.Type == models.AccountTypeAsset || account.Type == models.AccountTypeExpense {
				// Normal balance = DEBIT
				// Debit increases (+), Credit decreases (-)
				balanceChange = line.DebitAmount.InexactFloat64() - line.CreditAmount.InexactFloat64()
			} else {
				// Normal balance = CREDIT (Liability, Equity, Revenue)
				// Credit increases (+), Debit decreases (-)
				balanceChange = line.CreditAmount.InexactFloat64() - line.DebitAmount.InexactFloat64()
			}
			
			// Update account balance
			if err := tx.Model(&models.Account{}).
				Where("id = ?", line.AccountID).
				UpdateColumn("balance", gorm.Expr("balance + ?", balanceChange)).Error; err != nil {
				return nil, fmt.Errorf("failed to update account %d balance: %w", line.AccountID, err)
			}
			
			log.Printf("âœ… Updated account %d (%s) balance: %+.2f", line.AccountID, account.Code, balanceChange)
		}
	}
	
	return entryModel, nil
}

func (s *UnifiedJournalService) GetAccountBalances() ([]models.Account, error) {
	// Try to load from SSOT materialized view if available; otherwise, return empty slice safely
	var balances []models.Account
	if err := s.db.Limit(0).Find(&balances).Error; err != nil {
		// Return empty without failing callers
		return []models.Account{}, nil
	}
	return balances, nil
}

// GetJournalEntries returns paginated journal entries based on simple filters
func (s *UnifiedJournalService) GetJournalEntries(filters interface{}) (*JournalResponse, error) {
	f, ok := filters.(JournalFilters)
	if !ok {
		return nil, fmt.Errorf("invalid filters type")
	}

	query := s.db.Model(&models.SSOTJournalEntry{})
	if f.SourceType != "" {
		query = query.Where("source_type = ?", f.SourceType)
	}
	if f.SourceID != nil {
		query = query.Where("source_id = ?", *f.SourceID)
	}
	if f.DateFrom != nil {
		query = query.Where("entry_date >= ?", *f.DateFrom)
	}
	if f.DateTo != nil {
		query = query.Where("entry_date < ?", *f.DateTo)
	}

	var total int64
	if err := query.Count(&total).Error; err != nil {
		return nil, fmt.Errorf("failed to count journal entries: %w", err)
	}

	page := f.Page
	if page <= 0 {
		page = 1
	}
	limit := f.Limit
	if limit <= 0 {
		limit = 20
	}
	offset := (page - 1) * limit

	var entries []models.SSOTJournalEntry
	if err := query.
		Preload("Lines").
		Preload("Lines.Account").
		Order("entry_date DESC, id DESC").
		Limit(limit).
		Offset(offset).
		Find(&entries).Error; err != nil {
		return nil, fmt.Errorf("failed to query journal entries: %w", err)
	}

	return &JournalResponse{
		Data:       entries,
		Total:      total,
		Page:       page,
		Limit:      limit,
		TotalPages: int((total + int64(limit) - 1) / int64(limit)),
	}, nil
}

func (s *UnifiedJournalService) RefreshAccountBalances() error {
	// No-op in this minimal implementation
	return nil
}

// UltraFastPostingService STUB
type UltraFastPostingService struct {
	db *gorm.DB
}

func NewUltraFastPostingService(db *gorm.DB) *UltraFastPostingService {
	return &UltraFastPostingService{db: db}
}

func (s *UltraFastPostingService) UltraFastReceivablePaymentPosting(payment interface{}, contact interface{}, cashBank interface{}) error {
	return fmt.Errorf("ultra fast receivable payment posting has been disabled to prevent auto-posting")
}

func (s *UltraFastPostingService) UltraFastPayablePaymentPosting(payment interface{}, contact interface{}, cashBank interface{}) error {
	return fmt.Errorf("ultra fast payable payment posting has been disabled to prevent auto-posting")
}

func (s *UltraFastPostingService) CreateJournalEntryAsyncWithType(payment interface{}, userID interface{}, contactID interface{}, entryType string) error {
	return fmt.Errorf("async journal entry creation has been disabled to prevent auto-posting")
}

// Missing journal request types
type JournalLineRequest struct {
	AccountID   uint64
	DebitAmount decimal.Decimal
	CreditAmount decimal.Decimal
	Description string
}

type JournalEntryRequest struct {
	EntryDate   time.Time
	Reference   string
	Description string
	Lines       []JournalLineRequest
	CreatedBy   uint64
	SourceType  string
	SourceID    uint64
	AutoPost    bool
}

// Helpers to resolve default accounts for cash/bank journals
func findDefaultEquityAccountID(tx *gorm.DB) (uint64, error) {
	// Try code 3101 first
	type row struct{ ID uint64; Code string; Type string }
	var r row
	if err := tx.Raw("SELECT id, code, type FROM accounts WHERE deleted_at IS NULL AND code = '3101' LIMIT 1").Scan(&r).Error; err == nil && r.ID > 0 {
		return r.ID, nil
	}
	// Fallback: any EQUITY account
	r = row{}
	if err := tx.Raw("SELECT id, code, type FROM accounts WHERE deleted_at IS NULL AND type = 'EQUITY' ORDER BY code LIMIT 1").Scan(&r).Error; err == nil && r.ID > 0 {
		return r.ID, nil
	}
	return 0, fmt.Errorf("no default EQUITY account found")
}

func findDefaultExpenseAccountID(tx *gorm.DB) (uint64, error) {
	// Try code 6101 (Misc Expense) as a common default if exists
	type row struct{ ID uint64; Code string; Type string }
	var r row
	if err := tx.Raw("SELECT id, code, type FROM accounts WHERE deleted_at IS NULL AND code = '6101' LIMIT 1").Scan(&r).Error; err == nil && r.ID > 0 {
		return r.ID, nil
	}
	// Fallback: any EXPENSE account
	r = row{}
	if err := tx.Raw("SELECT id, code, type FROM accounts WHERE deleted_at IS NULL AND type = 'EXPENSE' ORDER BY code LIMIT 1").Scan(&r).Error; err == nil && r.ID > 0 {
		return r.ID, nil
	}
	return 0, fmt.Errorf("no default EXPENSE account found")
}

// UltraFastPaymentService STUB
type UltraFastPaymentService struct {
	db *gorm.DB
}

func NewUltraFastPaymentService(db *gorm.DB) *UltraFastPaymentService {
	return &UltraFastPaymentService{db: db}
}

func (s *UltraFastPaymentService) RecordPaymentUltraFast(request *UltraFastPaymentRequest) error {
	return fmt.Errorf("ultra fast payment recording has been disabled to prevent auto-posting")
}

func (s *UltraFastPaymentService) CreateJournalEntryAsync(request interface{}) error {
	return fmt.Errorf("async journal entry creation has been disabled to prevent auto-posting")
}

// UltraFastPaymentRequest stub type
type UltraFastPaymentRequest struct {
	ContactID   uint64
	Amount      float64
	Reference   string
	Notes       string
	UserID      uint64
}

// Missing types for controllers
type JournalFilters struct {
	StartDate   time.Time
	EndDate     time.Time
	DateFrom    *time.Time  // Add missing DateFrom field
	DateTo      *time.Time  // Add missing DateTo field  
	AccountID   uint
	SourceType  string
	SourceID    *uint64
	Page        int
	Limit       int
}

type JournalResponse struct {
	Data       []models.SSOTJournalEntry
	Total      int64
	Page       int
	Limit      int
	TotalPages int
}
