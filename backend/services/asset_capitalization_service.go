package services

import (
    "fmt"
    "time"

    "app-sistem-akuntansi/models"
    "app-sistem-akuntansi/repositories"
    "github.com/shopspring/decimal"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

// AssetCapitalizationService handles creating capitalization journals for fixed assets
// It writes both SSOT journal entries and legacy GL entries (journal_entries + journal_lines) and posts them.
// Capitalization moves cost from Inventory/Expense into Fixed Asset accounts.
type AssetCapitalizationService struct {
    db                    *gorm.DB
    accountRepo           repositories.AccountRepository
    unifiedJournalService *UnifiedJournalService
    journalRepo           repositories.JournalEntryRepository
}

func NewAssetCapitalizationService(db *gorm.DB, accountRepo repositories.AccountRepository, ujs *UnifiedJournalService, jr repositories.JournalEntryRepository) *AssetCapitalizationService {
    return &AssetCapitalizationService{
        db:                    db,
        accountRepo:           accountRepo,
        unifiedJournalService: ujs,
        journalRepo:           jr,
    }
}

// CapitalizationInput describes the data needed to capitalize an asset
// Amount should be the acquisition cost to be capitalized (excluding input VAT)
// Reference can be purchase code/receipt number for traceability
// sourceAccountID is where the cost currently sits (inventory or expense) and will be credited
// fixedAssetAccountID is the target asset account and will be debited
// referenceType/ID are stored for linking
type CapitalizationInput struct {
    AssetID             uint
    Amount              float64
    Date                time.Time
    Description         string
    Reference           string
    SourceAccountID     uint
    FixedAssetAccountID uint
    UserID              uint
    ReferenceType       string
    ReferenceID         uint
}

// Capitalize creates SSOT and legacy journals atomically
func (s *AssetCapitalizationService) Capitalize(input CapitalizationInput) error {
    if input.Amount <= 0 {
        return fmt.Errorf("capitalization amount must be > 0")
    }

    // Begin transaction
    tx := s.db.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // 1) Create legacy journal entry with two lines (Dr Fixed Asset, Cr Source)
    // Determine reference type/id flexibly
    refType := input.ReferenceType
    var refID *uint
    if refType == "" {
        refType = models.JournalRefAsset
    }
    if input.ReferenceID != 0 {
        refID = &input.ReferenceID
    } else {
        refID = &input.AssetID
    }

    je := &models.JournalEntry{
        EntryDate:       input.Date,
        Description:     nonEmpty(input.Description, fmt.Sprintf("Asset Capitalization - Asset #%d", input.AssetID)),
        ReferenceType:   refType,
        ReferenceID:     refID,
        Reference:       nonEmpty(input.Reference, fmt.Sprintf("ASSET-%d", input.AssetID)),
        UserID:          input.UserID,
        Status:          models.JournalStatusDraft,
        IsAutoGenerated: true,
        TotalDebit:      input.Amount,
        TotalCredit:     input.Amount,
        IsBalanced:      true,
    }

    lines := []models.JournalLine{
        { // Dr Fixed Asset
            AccountID:    input.FixedAssetAccountID,
            Description:  "Capitalization to Fixed Asset",
            DebitAmount:  input.Amount,
            CreditAmount: 0,
            LineNumber:   1,
        },
        { // Cr Source (Inventory/Expense)
            AccountID:    input.SourceAccountID,
            Description:  "Capitalization from Source",
            DebitAmount:  0,
            CreditAmount: input.Amount,
            LineNumber:   2,
        },
    }
    je.JournalLines = lines

    if err := tx.Create(je).Error; err != nil {
        tx.Rollback()
        return fmt.Errorf("failed to create legacy capitalization journal: %v", err)
    }
    
    // Reload journal entry to get the generated ID and ensure it's in the transaction context
    if err := tx.Session(&gorm.Session{Logger: logger.Default.LogMode(logger.Silent)}).
        Preload("JournalLines").First(je, je.ID).Error; err != nil {
        tx.Rollback()
        return fmt.Errorf("failed to reload capitalization journal: %v", err)
    }
    
    // Post legacy journal to update COA balances within the same transaction
    // Manual posting logic since PostJournalEntry uses a separate DB context
    if je.Status == models.JournalStatusDraft {
        je.Status = models.JournalStatusPosted
        je.PostedBy = &input.UserID
        now := time.Now()
        je.PostingDate = &now
        
        if err := tx.Save(je).Error; err != nil {
            tx.Rollback()
            return fmt.Errorf("failed to update journal status: %v", err)
        }
        
        // Update account balances for each line
        for _, line := range je.JournalLines {
            var account models.Account
            if err := tx.First(&account, line.AccountID).Error; err != nil {
                tx.Rollback()
                return fmt.Errorf("failed to find account %d: %v", line.AccountID, err)
            }
            
            // Update balance based on normal balance
            normalBalance := account.GetNormalBalance()
            if normalBalance == models.NormalBalanceDebit {
                account.Balance += line.DebitAmount - line.CreditAmount
            } else {
                account.Balance += line.CreditAmount - line.DebitAmount
            }
            
            if err := tx.Save(&account).Error; err != nil {
                tx.Rollback()
                return fmt.Errorf("failed to update account balance: %v", err)
            }
        }
    }

    // 2) Create SSOT journal entry
    if s.unifiedJournalService != nil {
        // Determine SSOT source type/id
        ssotSourceType := models.SSOTSourceTypeAsset
        ssotSourceID := uint64(input.AssetID)
        if input.AssetID == 0 {
            // fallback to purchase/receipt reference
            ssotSourceType = models.SSOTSourceTypePurchase
            ssotSourceID = uint64(input.ReferenceID)
        }
        req := &JournalEntryRequest{
            SourceType:  ssotSourceType,
            SourceID:    ssotSourceID,
            Reference:   je.Reference,
            EntryDate:   input.Date,
            Description: je.Description,
            AutoPost:    true,
            CreatedBy:   uint64(input.UserID),
            Lines: []JournalLineRequest{
                { // Dr Fixed Asset
                    AccountID:    uint64(input.FixedAssetAccountID),
                    Description:  "Capitalization to Fixed Asset",
                    DebitAmount:  decimal.NewFromFloat(input.Amount),
                    CreditAmount: decimal.Zero,
                },
                { // Cr Source
                    AccountID:    uint64(input.SourceAccountID),
                    Description:  "Capitalization from Source",
                    DebitAmount:  decimal.Zero,
                    CreditAmount: decimal.NewFromFloat(input.Amount),
                },
            },
        }
        if _, err := s.unifiedJournalService.CreateJournalEntry(req); err != nil {
            tx.Rollback()
            return fmt.Errorf("failed to create SSOT capitalization journal: %v", err)
        }
    }

    if err := tx.Commit().Error; err != nil {
        return fmt.Errorf("failed to commit capitalization: %v", err)
    }
    return nil
}

func nonEmpty(val, fallback string) string {
    if val != "" {
        return val
    }
    return fallback
}