package services

import (
	"context"
	"fmt"
	"math"
	"time"
	"app-sistem-akuntansi/models"
	"app-sistem-akuntansi/utils"
	"gorm.io/gorm"
)

type CashBankAccountingService struct {
	db     *gorm.DB
	logger *utils.JournalLogger
}

func NewCashBankAccountingService(db *gorm.DB) *CashBankAccountingService {
	return &CashBankAccountingService{
		db:     db,
		logger: utils.NewJournalLogger(db),
	}
}

// CreateTransactionWithJournal creates CashBank transaction and corresponding journal entry
func (s *CashBankAccountingService) CreateTransactionWithJournal(
	ctx context.Context,
	cashBankID uint,
	amount float64,
	referenceType string,
	referenceID uint,
	notes string,
	counterAccountID uint, // Account for the other side of the transaction
) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		// 1. Get CashBank with linked COA account
		var cashBank models.CashBank
		if err := tx.Preload("Account").First(&cashBank, cashBankID).Error; err != nil {
			return fmt.Errorf("cash bank not found: %v", err)
		}

		if cashBank.AccountID == 0 {
			return fmt.Errorf("cash bank %s not linked to COA account", cashBank.Name)
		}

		// 2. Create CashBank Transaction
		cashBankTx := &models.CashBankTransaction{
			CashBankID:      cashBankID,
			Amount:          amount,
			BalanceAfter:    cashBank.Balance + amount,
			TransactionDate: time.Now(),
			ReferenceType:   referenceType,
			ReferenceID:     referenceID,
			Notes:           notes,
		}

		if err := tx.Create(cashBankTx).Error; err != nil {
			return fmt.Errorf("failed to create cash bank transaction: %v", err)
		}

		// 3. Update CashBank Balance
		if err := tx.Model(&cashBank).Update("balance", cashBank.Balance+amount).Error; err != nil {
			return fmt.Errorf("failed to update cash bank balance: %v", err)
		}

		// 4. Get user from context
		userID, err := utils.GetUserIDFromContext(ctx)
		if err != nil {
			// Fallback to system user if context doesn't have user
			s.logger.LogWarning(ctx, "No user found in context for CashBank transaction, using system user", map[string]interface{}{
				"cash_bank_id": cashBankID,
				"amount": amount,
				"reference_type": referenceType,
			})
			userID = 1 // System user fallback
		}

		// 5. Create Journal Entry using the new JournalEntry model
		journal := &models.JournalEntry{
			Description:     fmt.Sprintf("CashBank: %s - %s", cashBank.Name, notes),
			Reference:       fmt.Sprintf("CB-%d", cashBankTx.ID),
			ReferenceType:   models.JournalRefCashBank,
			ReferenceID:     &cashBankTx.ID,
			EntryDate:       cashBankTx.TransactionDate,
			Status:          models.JournalStatusPosted,
			UserID:          userID,
			IsAutoGenerated: true,
			Notes:           notes,
		}

		if err := tx.Create(journal).Error; err != nil {
			s.logger.LogValidationError(ctx, nil, "journal_creation", err)
			return fmt.Errorf("failed to create journal entry: %v", err)
		}

		// Log journal creation
		s.logger.LogJournalCreation(ctx, journal)

		// 5. Create Journal Lines (Double Entry)
		lines := []models.JournalLine{}

		// Debit/Credit Cash/Bank Account based on amount
		if amount > 0 {
			// Positive amount: Debit Cash/Bank Account
			lines = append(lines, models.JournalLine{
				JournalEntryID: journal.ID,
				AccountID:      cashBank.AccountID,
				DebitAmount:    amount,
				CreditAmount:   0,
				Description:    notes,
				LineNumber:     1,
			})
			// Credit Counter Account
			lines = append(lines, models.JournalLine{
				JournalEntryID: journal.ID,
				AccountID:      counterAccountID,
				DebitAmount:    0,
				CreditAmount:   amount,
				Description:    notes,
				LineNumber:     2,
			})
		} else {
			// Negative amount: Credit Cash/Bank Account
			absAmount := math.Abs(amount)
			lines = append(lines, models.JournalLine{
				JournalEntryID: journal.ID,
				AccountID:      cashBank.AccountID,
				DebitAmount:    0,
				CreditAmount:   absAmount,
				Description:    notes,
				LineNumber:     1,
			})
			// Debit Counter Account
			lines = append(lines, models.JournalLine{
				JournalEntryID: journal.ID,
				AccountID:      counterAccountID,
				DebitAmount:    absAmount,
				CreditAmount:   0,
				Description:    notes,
				LineNumber:     2,
			})
		}

		// Create journal lines
		for _, line := range lines {
			if err := tx.Create(&line).Error; err != nil {
				return fmt.Errorf("failed to create journal line: %v", err)
			}
		}

		// 6. Update journal entry totals
		journal.TotalDebit = math.Abs(amount)
		journal.TotalCredit = math.Abs(amount)
		journal.IsBalanced = true
		if err := tx.Save(journal).Error; err != nil {
			return fmt.Errorf("failed to update journal totals: %v", err)
		}

		// 7. Update COA Account Balances
		if err := s.updateAccountBalance(tx, cashBank.AccountID, amount); err != nil {
			return fmt.Errorf("failed to update cash bank COA balance: %v", err)
		}

		if err := s.updateAccountBalance(tx, counterAccountID, -amount); err != nil {
			return fmt.Errorf("failed to update counter account balance: %v", err)
		}

		return nil
	})
}

// updateAccountBalance updates account balance based on account type and accounting rules
func (s *CashBankAccountingService) updateAccountBalance(tx *gorm.DB, accountID uint, amount float64) error {
	var account models.Account
	if err := tx.First(&account, accountID).Error; err != nil {
		return err
	}

	newBalance := account.Balance

	// Apply accounting rules based on account type
	switch account.Type {
	case models.AccountTypeAsset:
		newBalance += amount // Debit increases assets
	case models.AccountTypeLiability, models.AccountTypeEquity, models.AccountTypeRevenue:
		newBalance -= amount // Credit increases liabilities/equity/revenue (but we pass negative for credits)
	case models.AccountTypeExpense:
		newBalance += amount // Debit increases expenses
	}

	return tx.Model(&account).Update("balance", newBalance).Error
}

// ProcessCashBankDeposit handles cash/bank deposits (money coming in)
func (s *CashBankAccountingService) ProcessCashBankDeposit(
	ctx context.Context,
	cashBankID uint,
	amount float64,
	sourceAccountID uint, // Where money comes from (e.g., revenue account)
	referenceType string,
	referenceID uint,
	notes string,
) error {
	if amount <= 0 {
		return fmt.Errorf("deposit amount must be positive")
	}

	return s.CreateTransactionWithJournal(
		ctx,
		cashBankID,
		amount,
		referenceType,
		referenceID,
		notes,
		sourceAccountID,
	)
}

// ProcessCashBankWithdrawal handles cash/bank withdrawals (money going out)
func (s *CashBankAccountingService) ProcessCashBankWithdrawal(
	ctx context.Context,
	cashBankID uint,
	amount float64,
	targetAccountID uint, // Where money goes to (e.g., expense account)
	referenceType string,
	referenceID uint,
	notes string,
) error {
	if amount <= 0 {
		return fmt.Errorf("withdrawal amount must be positive")
	}

	// Pass negative amount for withdrawal
	return s.CreateTransactionWithJournal(
		ctx,
		cashBankID,
		-amount,
		referenceType,
		referenceID,
		notes,
		targetAccountID,
	)
}

// ProcessCashBankTransfer handles transfers between cash/bank accounts
func (s *CashBankAccountingService) ProcessCashBankTransfer(
	ctx context.Context,
	fromCashBankID uint,
	toCashBankID uint,
	amount float64,
	notes string,
) error {
	if amount <= 0 {
		return fmt.Errorf("transfer amount must be positive")
	}

	return s.db.Transaction(func(tx *gorm.DB) error {
		// Get both cash bank accounts
		var fromCashBank, toCashBank models.CashBank
		if err := tx.First(&fromCashBank, fromCashBankID).Error; err != nil {
			return fmt.Errorf("source cash bank not found: %v", err)
		}
		if err := tx.First(&toCashBank, toCashBankID).Error; err != nil {
			return fmt.Errorf("destination cash bank not found: %v", err)
		}

		if fromCashBank.AccountID == 0 || toCashBank.AccountID == 0 {
			return fmt.Errorf("both cash banks must be linked to COA accounts")
		}

		// Create withdrawal from source
		if err := s.CreateTransactionWithJournal(
			ctx,
			fromCashBankID,
			-amount,
			models.JournalRefTransfer,
			toCashBankID, // Reference the destination as ID
			fmt.Sprintf("Transfer to %s - %s", toCashBank.Name, notes),
			toCashBank.AccountID,
		); err != nil {
			return fmt.Errorf("failed to create withdrawal transaction: %v", err)
		}

		// Create deposit to destination
		if err := s.CreateTransactionWithJournal(
			ctx,
			toCashBankID,
			amount,
			models.JournalRefTransfer,
			fromCashBankID, // Reference the source as ID
			fmt.Sprintf("Transfer from %s - %s", fromCashBank.Name, notes),
			fromCashBank.AccountID,
		); err != nil {
			return fmt.Errorf("failed to create deposit transaction: %v", err)
		}

		return nil
	})
}

// RecalculateCashBankBalance recalculates cash bank balance from transactions and syncs with COA
func (s *CashBankAccountingService) RecalculateCashBankBalance(cashBankID uint) error {
	return s.db.Transaction(func(tx *gorm.DB) error {
		// Get cash bank with linked account
		var cashBank models.CashBank
		if err := tx.First(&cashBank, cashBankID).Error; err != nil {
			return fmt.Errorf("cash bank not found: %v", err)
		}

		if cashBank.AccountID == 0 {
			return fmt.Errorf("cash bank %s not linked to COA account", cashBank.Name)
		}

		// Calculate sum of all transactions
		var transactionSum float64
		if err := tx.Model(&models.CashBankTransaction{}).
			Where("cash_bank_id = ? AND deleted_at IS NULL", cashBankID).
			Select("COALESCE(SUM(amount), 0)").
			Scan(&transactionSum).Error; err != nil {
			return fmt.Errorf("failed to calculate transaction sum: %v", err)
		}

		// Update cash bank balance
		if err := tx.Model(&cashBank).Update("balance", transactionSum).Error; err != nil {
			return fmt.Errorf("failed to update cash bank balance: %v", err)
		}

		// Update linked COA account balance
		if err := tx.Model(&models.Account{}).
			Where("id = ?", cashBank.AccountID).
			Update("balance", transactionSum).Error; err != nil {
			return fmt.Errorf("failed to update COA account balance: %v", err)
		}

		return nil
	})
}

// SyncAllCashBankBalances syncs all cash bank balances with their COA accounts
func (s *CashBankAccountingService) SyncAllCashBankBalances() error {
	var cashBanks []models.CashBank
	if err := s.db.Where("account_id > 0 AND deleted_at IS NULL").Find(&cashBanks).Error; err != nil {
		return fmt.Errorf("failed to get cash banks: %v", err)
	}

	for _, cb := range cashBanks {
		if err := s.RecalculateCashBankBalance(cb.ID); err != nil {
			return fmt.Errorf("failed to sync cash bank %s: %v", cb.Name, err)
		}
	}

	return nil
}
