-- Migration 022: Install Purchase Balance Validation Functions (PostgreSQL Compatible)
-- Purpose: Install core purchase balance validation functions for PostgreSQL
-- Date: 2025-09-26
-- Priority: High (after sales balance system)

-- Check if migration already exists
SELECT CASE 
    WHEN EXISTS (SELECT 1 FROM migration_logs WHERE migration_name = '022_purchase_balance_validation_postgresql') 
    THEN 'Purchase Balance Functions already installed!' 
    ELSE 'Installing Purchase Balance Functions...' 
END as migration_status;

-- ===========================================================================
-- STEP 1: CREATE ACCOUNTS PAYABLE ACCOUNT IF NOT EXISTS
-- ===========================================================================

INSERT INTO accounts (code, name, type, balance, created_at, updated_at)
VALUES ('2101', 'Hutang Usaha', 'LIABILITY', 0.00, NOW(), NOW())
ON CONFLICT (code) DO NOTHING;

-- ===========================================================================
-- STEP 2: CREATE PURCHASE BALANCE VALIDATION FUNCTIONS
-- ===========================================================================

DROP FUNCTION IF EXISTS validate_purchase_balances();

CREATE OR REPLACE FUNCTION validate_purchase_balances() RETURNS JSON AS $$
DECLARE
    validation_result JSON;
    total_outstanding DECIMAL(15,2) := 0;
    current_ap_balance DECIMAL(15,2) := 0;
    expected_ap_balance DECIMAL(15,2) := 0;
    balance_discrepancy DECIMAL(15,2) := 0;
    accounts_payable_account_id INTEGER := NULL;
    issue_count INTEGER := 0;
    validation_status VARCHAR(20) := 'PASSED';
    bank_balance_discrepancy DECIMAL(15,2) := 0;
    total_payments_recorded DECIMAL(15,2) := 0;
    total_purchase_paid_amount DECIMAL(15,2) := 0;
BEGIN
    -- Get total outstanding amount from purchases (credit purchases only)
    SELECT COALESCE(SUM(outstanding_amount), 0) 
    INTO total_outstanding
    FROM purchases 
    WHERE payment_method = 'CREDIT' 
      AND deleted_at IS NULL;
      
    -- Get total paid amount from purchases for verification
    SELECT COALESCE(SUM(paid_amount), 0) 
    INTO total_purchase_paid_amount
    FROM purchases 
    WHERE deleted_at IS NULL;
    
    -- Get total payments recorded in purchase_payments table (if exists)
    BEGIN
        SELECT COALESCE(SUM(amount), 0) 
        INTO total_payments_recorded
        FROM purchase_payments 
        WHERE deleted_at IS NULL;
    EXCEPTION
        WHEN SQLSTATE '42P01' THEN
            total_payments_recorded := 0;
    END;
    
    -- Find Accounts Payable account (Hutang Usaha)
    SELECT id INTO accounts_payable_account_id
    FROM accounts 
    WHERE (code = '2101' OR code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Get current Accounts Payable balance
    IF accounts_payable_account_id IS NOT NULL THEN
        SELECT COALESCE(balance, 0) 
        INTO current_ap_balance
        FROM accounts 
        WHERE id = accounts_payable_account_id;
    END IF;
    
    -- Expected AP balance should be NEGATIVE (liability)
    -- Outstanding purchases create liability, so expected balance = -total_outstanding
    expected_ap_balance := -total_outstanding;
    balance_discrepancy := current_ap_balance - expected_ap_balance;
    
    -- Check for issues
    IF ABS(balance_discrepancy) > 1.00 THEN
        issue_count := issue_count + 1;
        validation_status := 'FAILED';
    END IF;
    
    -- Check payment consistency
    bank_balance_discrepancy := total_purchase_paid_amount - total_payments_recorded;
    IF ABS(bank_balance_discrepancy) > 1.00 THEN
        issue_count := issue_count + 1;
        validation_status := 'FAILED';
    END IF;
    
    -- Build validation result using PostgreSQL JSON functions
    validation_result := json_build_object(
        'validation_timestamp', NOW(),
        'status', validation_status,
        'issue_count', issue_count,
        'accounts_payable', json_build_object(
            'account_id', accounts_payable_account_id,
            'current_balance', current_ap_balance,
            'expected_balance', expected_ap_balance,
            'discrepancy', balance_discrepancy,
            'is_correct', ABS(balance_discrepancy) <= 1.00
        ),
        'purchase_summary', json_build_object(
            'total_outstanding', total_outstanding,
            'total_paid_amount', total_purchase_paid_amount,
            'total_payments_recorded', total_payments_recorded,
            'payment_discrepancy', bank_balance_discrepancy,
            'payments_consistent', ABS(bank_balance_discrepancy) <= 1.00
        ),
        'recommendations', 
        CASE 
            WHEN validation_status = 'PASSED' THEN 
                json_build_array('No action needed - balances are correct')
            ELSE 
                json_build_array(
                    CASE WHEN ABS(balance_discrepancy) > 1.00 
                         THEN 'Fix Accounts Payable balance discrepancy' 
                         ELSE NULL END,
                    CASE WHEN ABS(bank_balance_discrepancy) > 1.00 
                         THEN 'Reconcile purchase payment records' 
                         ELSE NULL END
                )
        END
    );
    
    RETURN validation_result;
END;
$$ LANGUAGE plpgsql;

-- ===========================================================================
-- STEP 3: CREATE PURCHASE BALANCE SYNC FUNCTION
-- ===========================================================================

DROP FUNCTION IF EXISTS sync_purchase_balances();

CREATE OR REPLACE FUNCTION sync_purchase_balances() RETURNS JSON AS $$
DECLARE
    sync_result JSON;
    total_outstanding DECIMAL(15,2) := 0;
    expected_ap_balance DECIMAL(15,2) := 0;
    accounts_payable_account_id INTEGER := NULL;
    old_ap_balance DECIMAL(15,2) := 0;
    balance_updated BOOLEAN := FALSE;
    updates_made INTEGER := 0;
    affected_rows INTEGER := 0;
BEGIN
    -- Get total outstanding from credit purchases
    SELECT COALESCE(SUM(outstanding_amount), 0) 
    INTO total_outstanding
    FROM purchases 
    WHERE payment_method = 'CREDIT' 
      AND deleted_at IS NULL;
    
    -- Find Accounts Payable account
    SELECT id, balance 
    INTO accounts_payable_account_id, old_ap_balance
    FROM accounts 
    WHERE (code = '2101' OR code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Calculate expected balance (negative for liability)
    expected_ap_balance := -total_outstanding;
    
    -- Update Accounts Payable balance if discrepancy exists
    IF accounts_payable_account_id IS NOT NULL AND ABS(old_ap_balance - expected_ap_balance) > 1.00 THEN
        UPDATE accounts 
        SET balance = expected_ap_balance,
            updated_at = NOW()
        WHERE id = accounts_payable_account_id;
        
        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        balance_updated := TRUE;
        updates_made := updates_made + affected_rows;
    END IF;
    
    -- Fix individual purchase outstanding amounts that might be inconsistent
    UPDATE purchases 
    SET outstanding_amount = total_amount - paid_amount,
        updated_at = NOW()
    WHERE ABS(outstanding_amount - (total_amount - paid_amount)) > 0.01
      AND deleted_at IS NULL;
      
    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    updates_made := updates_made + affected_rows;
    
    -- Build sync result
    sync_result := json_build_object(
        'sync_timestamp', NOW(),
        'updates_made', updates_made,
        'accounts_payable_updated', balance_updated,
        'accounts_payable', json_build_object(
            'account_id', accounts_payable_account_id,
            'old_balance', old_ap_balance,
            'new_balance', expected_ap_balance,
            'total_outstanding', total_outstanding
        ),
        'status', CASE WHEN updates_made > 0 THEN 'UPDATED' ELSE 'NO_CHANGES_NEEDED' END
    );
    
    RETURN sync_result;
END;
$$ LANGUAGE plpgsql;

-- ===========================================================================
-- STEP 4: CREATE PURCHASE BALANCE STATUS FUNCTION
-- ===========================================================================

DROP FUNCTION IF EXISTS get_purchase_balance_status();

CREATE OR REPLACE FUNCTION get_purchase_balance_status() RETURNS JSON AS $$
DECLARE
    status_result JSON;
    total_purchases INTEGER := 0;
    credit_purchases INTEGER := 0;
    total_outstanding DECIMAL(15,2) := 0;
    total_paid DECIMAL(15,2) := 0;
    ap_balance DECIMAL(15,2) := 0;
    total_bank_balance DECIMAL(15,2) := 0;
BEGIN
    -- Get purchase counts and amounts
    SELECT 
        COUNT(*)::INTEGER,
        COALESCE(SUM(CASE WHEN payment_method = 'CREDIT' THEN 1 ELSE 0 END), 0)::INTEGER,
        COALESCE(SUM(outstanding_amount), 0),
        COALESCE(SUM(paid_amount), 0)
    INTO total_purchases, credit_purchases, total_outstanding, total_paid
    FROM purchases 
    WHERE deleted_at IS NULL;
    
    -- Get Accounts Payable balance
    SELECT COALESCE(balance, 0) 
    INTO ap_balance
    FROM accounts 
    WHERE (code = '2101' OR code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Get total bank balance (cash accounts)
    SELECT COALESCE(SUM(balance), 0) 
    INTO total_bank_balance
    FROM accounts 
    WHERE code LIKE '110%' -- Cash and bank accounts
      AND deleted_at IS NULL;
    
    -- Build status result
    status_result := json_build_object(
        'timestamp', NOW(),
        'purchase_summary', json_build_object(
            'total_purchases', total_purchases,
            'credit_purchases', credit_purchases,
            'total_outstanding', total_outstanding,
            'total_paid', total_paid
        ),
        'account_balances', json_build_object(
            'accounts_payable_balance', ap_balance,
            'expected_ap_balance', -total_outstanding,
            'ap_balance_correct', ABS(ap_balance - (-total_outstanding)) <= 1.00,
            'total_bank_balance', total_bank_balance
        ),
        'health_status', 
        CASE 
            WHEN ABS(ap_balance - (-total_outstanding)) <= 1.00 THEN 'HEALTHY'
            ELSE 'NEEDS_ATTENTION'
        END
    );
    
    RETURN status_result;
END;
$$ LANGUAGE plpgsql;

-- ===========================================================================
-- STEP 5: RUN INITIAL SYNC
-- ===========================================================================

-- Run initial balance sync to fix any existing discrepancies
SELECT 'Running initial purchase balance sync...' as message;
SELECT sync_purchase_balances() as initial_sync_result;

-- Test validation
SELECT 'Testing purchase balance validation...' as message;
SELECT validate_purchase_balances() as validation_result;

-- ===========================================================================
-- STEP 6: LOG MIGRATION COMPLETION
-- ===========================================================================

INSERT INTO migration_logs (migration_name, executed_at, description, status)
VALUES (
    '022_purchase_balance_validation_postgresql',
    NOW(),
    'Installed Purchase Balance Validation Functions for PostgreSQL (validate_purchase_balances, sync_purchase_balances, get_purchase_balance_status)',
    'COMPLETED'
)
ON CONFLICT (migration_name) DO UPDATE SET 
    executed_at = NOW(),
    status = 'COMPLETED',
    description = EXCLUDED.description;

-- Success message
SELECT 'ðŸŽ‰ Purchase Balance Validation Functions installed successfully!' as result,
       'Functions: validate_purchase_balances(), sync_purchase_balances(), get_purchase_balance_status()' as available_functions,
       'Database: PostgreSQL Compatible' as database_type;