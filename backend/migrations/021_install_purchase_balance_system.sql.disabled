-- Migration 021: Install Purchase Balance Validation System
-- Purpose: Automatically install complete purchase balance validation system
-- Date: 2025-09-26
-- Priority: High (after sales balance system)

-- This migration will automatically run when backend starts up
-- and install all components needed for purchase balance validation

-- Check if migration already exists
SELECT CASE 
    WHEN EXISTS (SELECT 1 FROM migration_logs WHERE migration_name = '021_install_purchase_balance_system') 
    THEN 'Purchase Balance System already installed!' 
    ELSE 'Installing Purchase Balance System...' 
END as migration_status;

-- ===========================================================================
-- STEP 1: CREATE PURCHASE BALANCE VALIDATION FUNCTIONS
-- ===========================================================================

-- Note: DELIMITER is not used in migrations since they run through Go MySQL driver

DROP FUNCTION IF EXISTS validate_purchase_balances;

CREATE FUNCTION validate_purchase_balances() RETURNS JSON
READS SQL DATA
DETERMINISTIC
COMMENT 'Validates that Accounts Payable balances match purchase outstanding amounts'
BEGIN
    DECLARE validation_result JSON DEFAULT JSON_OBJECT();
    DECLARE total_outstanding DECIMAL(15,2) DEFAULT 0;
    DECLARE current_ap_balance DECIMAL(15,2) DEFAULT 0;
    DECLARE expected_ap_balance DECIMAL(15,2) DEFAULT 0;
    DECLARE balance_discrepancy DECIMAL(15,2) DEFAULT 0;
    DECLARE accounts_payable_account_id INT DEFAULT NULL;
    DECLARE issue_count INT DEFAULT 0;
    DECLARE validation_status VARCHAR(20) DEFAULT 'PASSED';
    DECLARE bank_balance_discrepancy DECIMAL(15,2) DEFAULT 0;
    DECLARE total_payments_recorded DECIMAL(15,2) DEFAULT 0;
    DECLARE total_purchase_paid_amount DECIMAL(15,2) DEFAULT 0;
    
    -- Get total outstanding amount from purchases (credit purchases only)
    SELECT COALESCE(SUM(outstanding_amount), 0) 
    INTO total_outstanding
    FROM purchases 
    WHERE payment_method = 'CREDIT' 
      AND deleted_at IS NULL;
      
    -- Get total paid amount from purchases for verification
    SELECT COALESCE(SUM(paid_amount), 0) 
    INTO total_purchase_paid_amount
    FROM purchases 
    WHERE deleted_at IS NULL;
    
    -- Get total payments recorded in purchase_payments table
    SELECT COALESCE(SUM(amount), 0) 
    INTO total_payments_recorded
    FROM purchase_payments 
    WHERE deleted_at IS NULL;
    
    -- Find Accounts Payable account (Hutang Usaha)
    SELECT id INTO accounts_payable_account_id
    FROM accounts 
    WHERE (code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Get current Accounts Payable balance
    IF accounts_payable_account_id IS NOT NULL THEN
        SELECT COALESCE(balance, 0) 
        INTO current_ap_balance
        FROM accounts 
        WHERE id = accounts_payable_account_id;
    END IF;
    
    -- Expected AP balance should be NEGATIVE (liability)
    -- Outstanding purchases create liability, so expected balance = -total_outstanding
    SET expected_ap_balance = -total_outstanding;
    SET balance_discrepancy = current_ap_balance - expected_ap_balance;
    
    -- Check for issues
    IF ABS(balance_discrepancy) > 1.00 THEN
        SET issue_count = issue_count + 1;
        SET validation_status = 'FAILED';
    END IF;
    
    -- Check payment consistency
    SET bank_balance_discrepancy = total_purchase_paid_amount - total_payments_recorded;
    IF ABS(bank_balance_discrepancy) > 1.00 THEN
        SET issue_count = issue_count + 1;
        SET validation_status = 'FAILED';
    END IF;
    
    -- Build validation result
    SET validation_result = JSON_OBJECT(
        'validation_timestamp', NOW(),
        'status', validation_status,
        'issue_count', issue_count,
        'accounts_payable', JSON_OBJECT(
            'account_id', accounts_payable_account_id,
            'current_balance', current_ap_balance,
            'expected_balance', expected_ap_balance,
            'discrepancy', balance_discrepancy,
            'is_correct', ABS(balance_discrepancy) <= 1.00
        ),
        'purchase_summary', JSON_OBJECT(
            'total_outstanding', total_outstanding,
            'total_paid_amount', total_purchase_paid_amount,
            'total_payments_recorded', total_payments_recorded,
            'payment_discrepancy', bank_balance_discrepancy,
            'payments_consistent', ABS(bank_balance_discrepancy) <= 1.00
        ),
        'recommendations', 
        CASE 
            WHEN validation_status = 'PASSED' THEN JSON_ARRAY('No action needed - balances are correct')
            ELSE JSON_ARRAY(
                CASE WHEN ABS(balance_discrepancy) > 1.00 
                     THEN 'Fix Accounts Payable balance discrepancy' 
                     ELSE NULL END,
                CASE WHEN ABS(bank_balance_discrepancy) > 1.00 
                     THEN 'Reconcile purchase payment records' 
                     ELSE NULL END
            )
        END
    );
    
    RETURN validation_result;
END;

-- ===========================================================================
-- STEP 2: CREATE PURCHASE BALANCE SYNC FUNCTION
-- ===========================================================================

DROP FUNCTION IF EXISTS sync_purchase_balances;

CREATE FUNCTION sync_purchase_balances() RETURNS JSON
READS SQL DATA
MODIFIES SQL DATA
DETERMINISTIC
COMMENT 'Automatically fixes purchase balance discrepancies'
BEGIN
    DECLARE sync_result JSON DEFAULT JSON_OBJECT();
    DECLARE total_outstanding DECIMAL(15,2) DEFAULT 0;
    DECLARE expected_ap_balance DECIMAL(15,2) DEFAULT 0;
    DECLARE accounts_payable_account_id INT DEFAULT NULL;
    DECLARE old_ap_balance DECIMAL(15,2) DEFAULT 0;
    DECLARE balance_updated BOOLEAN DEFAULT FALSE;
    DECLARE updates_made INT DEFAULT 0;
    
    -- Get total outstanding from credit purchases
    SELECT COALESCE(SUM(outstanding_amount), 0) 
    INTO total_outstanding
    FROM purchases 
    WHERE payment_method = 'CREDIT' 
      AND deleted_at IS NULL;
    
    -- Find Accounts Payable account
    SELECT id, balance 
    INTO accounts_payable_account_id, old_ap_balance
    FROM accounts 
    WHERE (code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Calculate expected balance (negative for liability)
    SET expected_ap_balance = -total_outstanding;
    
    -- Update Accounts Payable balance if discrepancy exists
    IF accounts_payable_account_id IS NOT NULL AND ABS(old_ap_balance - expected_ap_balance) > 1.00 THEN
        UPDATE accounts 
        SET balance = expected_ap_balance,
            updated_at = NOW()
        WHERE id = accounts_payable_account_id;
        
        SET balance_updated = TRUE;
        SET updates_made = updates_made + 1;
    END IF;
    
    -- Fix individual purchase outstanding amounts that might be inconsistent
    UPDATE purchases 
    SET outstanding_amount = total_amount - paid_amount,
        updated_at = NOW()
    WHERE ABS(outstanding_amount - (total_amount - paid_amount)) > 0.01
      AND deleted_at IS NULL;
      
    SET updates_made = updates_made + ROW_COUNT();
    
    -- Build sync result
    SET sync_result = JSON_OBJECT(
        'sync_timestamp', NOW(),
        'updates_made', updates_made,
        'accounts_payable_updated', balance_updated,
        'accounts_payable', JSON_OBJECT(
            'account_id', accounts_payable_account_id,
            'old_balance', old_ap_balance,
            'new_balance', expected_ap_balance,
            'total_outstanding', total_outstanding
        ),
        'status', CASE WHEN updates_made > 0 THEN 'UPDATED' ELSE 'NO_CHANGES_NEEDED' END
    );
    
    RETURN sync_result;
END;

-- ===========================================================================
-- STEP 3: CREATE PURCHASE BALANCE STATUS FUNCTION
-- ===========================================================================

DROP FUNCTION IF EXISTS get_purchase_balance_status;

CREATE FUNCTION get_purchase_balance_status() RETURNS JSON
READS SQL DATA
DETERMINISTIC
COMMENT 'Provides detailed purchase balance monitoring status'
BEGIN
    DECLARE status_result JSON DEFAULT JSON_OBJECT();
    DECLARE total_purchases INT DEFAULT 0;
    DECLARE credit_purchases INT DEFAULT 0;
    DECLARE total_outstanding DECIMAL(15,2) DEFAULT 0;
    DECLARE total_paid DECIMAL(15,2) DEFAULT 0;
    DECLARE ap_balance DECIMAL(15,2) DEFAULT 0;
    DECLARE total_bank_balance DECIMAL(15,2) DEFAULT 0;
    
    -- Get purchase counts and amounts
    SELECT 
        COUNT(*),
        COALESCE(SUM(CASE WHEN payment_method = 'CREDIT' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(outstanding_amount), 0),
        COALESCE(SUM(paid_amount), 0)
    INTO total_purchases, credit_purchases, total_outstanding, total_paid
    FROM purchases 
    WHERE deleted_at IS NULL;
    
    -- Get Accounts Payable balance
    SELECT COALESCE(balance, 0) 
    INTO ap_balance
    FROM accounts 
    WHERE (code LIKE '%2101%' OR name LIKE '%Hutang Usaha%' OR name LIKE '%Accounts Payable%')
      AND deleted_at IS NULL
    ORDER BY 
        CASE 
            WHEN code = '2101' THEN 1 
            WHEN code LIKE '2101%' THEN 2 
            WHEN name LIKE '%Hutang Usaha%' THEN 3
            ELSE 4 
        END
    LIMIT 1;
    
    -- Get total bank balance (cash accounts)
    SELECT COALESCE(SUM(balance), 0) 
    INTO total_bank_balance
    FROM accounts 
    WHERE code LIKE '110%' -- Cash and bank accounts
      AND deleted_at IS NULL;
    
    -- Build status result
    SET status_result = JSON_OBJECT(
        'timestamp', NOW(),
        'purchase_summary', JSON_OBJECT(
            'total_purchases', total_purchases,
            'credit_purchases', credit_purchases,
            'total_outstanding', total_outstanding,
            'total_paid', total_paid
        ),
        'account_balances', JSON_OBJECT(
            'accounts_payable_balance', ap_balance,
            'expected_ap_balance', -total_outstanding,
            'ap_balance_correct', ABS(ap_balance - (-total_outstanding)) <= 1.00,
            'total_bank_balance', total_bank_balance
        ),
        'health_status', 
        CASE 
            WHEN ABS(ap_balance - (-total_outstanding)) <= 1.00 THEN 'HEALTHY'
            ELSE 'NEEDS_ATTENTION'
        END
    );
    
    RETURN status_result;
END;

-- ===========================================================================
-- STEP 4: CREATE BALANCE SYNC LOG TABLE
-- ===========================================================================

CREATE TABLE IF NOT EXISTS balance_sync_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL COMMENT 'Type of entity that triggered sync (PURCHASE, PURCHASE_PAYMENT, etc)',
    entity_id BIGINT NOT NULL COMMENT 'ID of the entity that triggered sync',
    trigger_action VARCHAR(20) NOT NULL COMMENT 'Action that triggered sync (INSERT, UPDATE, DELETE)',
    sync_result JSON COMMENT 'JSON result from sync operation',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_balance_sync_log_entity (entity_type, entity_id),
    INDEX idx_balance_sync_log_created (created_at),
    
    UNIQUE KEY uk_balance_sync_log_entity_action (entity_type, entity_id, trigger_action)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci 
COMMENT='Audit log for balance sync operations';

-- ===========================================================================
-- STEP 5: CREATE AUTO-SYNC TRIGGERS
-- ===========================================================================

DELIMITER $$

-- Trigger: After Purchase Payment Insert
DROP TRIGGER IF EXISTS trg_purchase_payment_insert$$

CREATE TRIGGER trg_purchase_payment_insert
AFTER INSERT ON purchase_payments
FOR EACH ROW
BEGIN
    DECLARE sync_result JSON;
    
    -- Update the related purchase paid_amount and outstanding_amount
    UPDATE purchases 
    SET paid_amount = (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = NEW.purchase_id 
          AND deleted_at IS NULL
    ),
    outstanding_amount = total_amount - (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = NEW.purchase_id 
          AND deleted_at IS NULL
    ),
    updated_at = NOW()
    WHERE id = NEW.purchase_id;
    
    -- Auto-sync purchase balances
    SET sync_result = sync_purchase_balances();
    
    -- Log the sync action
    INSERT INTO balance_sync_log (
        entity_type,
        entity_id,
        trigger_action,
        sync_result,
        created_at
    ) VALUES (
        'PURCHASE_PAYMENT',
        NEW.id,
        'INSERT',
        sync_result,
        NOW()
    ) ON DUPLICATE KEY UPDATE
        sync_result = VALUES(sync_result),
        created_at = VALUES(created_at);

END$$

-- Trigger: After Purchase Payment Update
DROP TRIGGER IF EXISTS trg_purchase_payment_update$$

CREATE TRIGGER trg_purchase_payment_update
AFTER UPDATE ON purchase_payments
FOR EACH ROW
BEGIN
    DECLARE sync_result JSON;
    
    -- Update the old purchase if purchase_id changed
    IF OLD.purchase_id != NEW.purchase_id THEN
        UPDATE purchases 
        SET paid_amount = (
            SELECT COALESCE(SUM(amount), 0) 
            FROM purchase_payments 
            WHERE purchase_id = OLD.purchase_id 
              AND deleted_at IS NULL
        ),
        outstanding_amount = total_amount - (
            SELECT COALESCE(SUM(amount), 0) 
            FROM purchase_payments 
            WHERE purchase_id = OLD.purchase_id 
              AND deleted_at IS NULL
        ),
        updated_at = NOW()
        WHERE id = OLD.purchase_id;
    END IF;
    
    -- Update the new/current purchase
    UPDATE purchases 
    SET paid_amount = (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = NEW.purchase_id 
          AND deleted_at IS NULL
    ),
    outstanding_amount = total_amount - (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = NEW.purchase_id 
          AND deleted_at IS NULL
    ),
    updated_at = NOW()
    WHERE id = NEW.purchase_id;
    
    -- Auto-sync purchase balances
    SET sync_result = sync_purchase_balances();
    
    -- Log the sync action
    INSERT INTO balance_sync_log (
        entity_type,
        entity_id,
        trigger_action,
        sync_result,
        created_at
    ) VALUES (
        'PURCHASE_PAYMENT',
        NEW.id,
        'UPDATE',
        sync_result,
        NOW()
    ) ON DUPLICATE KEY UPDATE
        sync_result = VALUES(sync_result),
        created_at = VALUES(created_at);

END$$

-- Trigger: After Purchase Payment Delete
DROP TRIGGER IF EXISTS trg_purchase_payment_delete$$

CREATE TRIGGER trg_purchase_payment_delete
AFTER DELETE ON purchase_payments
FOR EACH ROW
BEGIN
    DECLARE sync_result JSON;
    
    -- Update the related purchase paid_amount and outstanding_amount
    UPDATE purchases 
    SET paid_amount = (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = OLD.purchase_id 
          AND deleted_at IS NULL
    ),
    outstanding_amount = total_amount - (
        SELECT COALESCE(SUM(amount), 0) 
        FROM purchase_payments 
        WHERE purchase_id = OLD.purchase_id 
          AND deleted_at IS NULL
    ),
    updated_at = NOW()
    WHERE id = OLD.purchase_id;
    
    -- Auto-sync purchase balances
    SET sync_result = sync_purchase_balances();
    
    -- Log the sync action
    INSERT INTO balance_sync_log (
        entity_type,
        entity_id,
        trigger_action,
        sync_result,
        created_at
    ) VALUES (
        'PURCHASE_PAYMENT',
        OLD.id,
        'DELETE',
        sync_result,
        NOW()
    ) ON DUPLICATE KEY UPDATE
        sync_result = VALUES(sync_result),
        created_at = VALUES(created_at);

END$$

-- Trigger: After Purchase Update
DROP TRIGGER IF EXISTS trg_purchase_update$$

CREATE TRIGGER trg_purchase_update
AFTER UPDATE ON purchases
FOR EACH ROW
BEGIN
    DECLARE sync_result JSON;
    
    -- Only sync if amounts have changed
    IF OLD.total_amount != NEW.total_amount 
       OR OLD.paid_amount != NEW.paid_amount 
       OR OLD.outstanding_amount != NEW.outstanding_amount
       OR OLD.payment_method != NEW.payment_method THEN
       
        -- Ensure outstanding_amount is calculated correctly
        IF NEW.outstanding_amount != (NEW.total_amount - NEW.paid_amount) THEN
            UPDATE purchases 
            SET outstanding_amount = total_amount - paid_amount,
                updated_at = NOW()
            WHERE id = NEW.id;
        END IF;
        
        -- Auto-sync purchase balances
        SET sync_result = sync_purchase_balances();
        
        -- Log the sync action
        INSERT INTO balance_sync_log (
            entity_type,
            entity_id,
            trigger_action,
            sync_result,
            created_at
        ) VALUES (
            'PURCHASE',
            NEW.id,
            'UPDATE',
            sync_result,
            NOW()
        ) ON DUPLICATE KEY UPDATE
            sync_result = VALUES(sync_result),
            created_at = VALUES(created_at);
    END IF;

END$$

DELIMITER ;

-- ===========================================================================
-- STEP 6: CREATE MONITORING VIEWS
-- ===========================================================================

-- Purchase Balance Monitoring View
CREATE OR REPLACE VIEW purchase_balance_monitoring AS
SELECT 
    'Purchase Balance Status' as check_name,
    JSON_UNQUOTE(JSON_EXTRACT(get_purchase_balance_status(), '$.health_status')) as status,
    JSON_UNQUOTE(JSON_EXTRACT(get_purchase_balance_status(), '$.purchase_summary.total_outstanding')) as total_outstanding,
    JSON_UNQUOTE(JSON_EXTRACT(get_purchase_balance_status(), '$.account_balances.accounts_payable_balance')) as ap_balance,
    JSON_UNQUOTE(JSON_EXTRACT(get_purchase_balance_status(), '$.account_balances.expected_ap_balance')) as expected_ap_balance,
    NOW() as last_checked;

-- Purchase Balance Health View
CREATE OR REPLACE VIEW purchase_balance_health AS
SELECT 
    p.id as purchase_id,
    p.code as purchase_code,
    p.vendor_id,
    p.total_amount,
    p.paid_amount,
    p.outstanding_amount,
    p.payment_method,
    p.status,
    
    -- Calculated fields
    (p.total_amount - p.paid_amount) as calculated_outstanding,
    ABS(p.outstanding_amount - (p.total_amount - p.paid_amount)) as outstanding_discrepancy,
    
    -- Payment summary from purchase_payments table
    COALESCE(payment_summary.total_payments, 0) as actual_payments,
    COALESCE(payment_summary.payment_count, 0) as payment_count,
    
    -- Health status
    CASE 
        WHEN ABS(p.outstanding_amount - (p.total_amount - p.paid_amount)) > 0.01 THEN 'INCONSISTENT'
        WHEN ABS(p.paid_amount - COALESCE(payment_summary.total_payments, 0)) > 0.01 THEN 'PAYMENT_MISMATCH'
        ELSE 'HEALTHY'
    END as health_status,
    
    p.updated_at as last_updated

FROM purchases p
LEFT JOIN (
    SELECT 
        purchase_id,
        SUM(amount) as total_payments,
        COUNT(*) as payment_count
    FROM purchase_payments
    WHERE deleted_at IS NULL
    GROUP BY purchase_id
) payment_summary ON p.id = payment_summary.purchase_id

WHERE p.deleted_at IS NULL
ORDER BY 
    CASE 
        WHEN ABS(p.outstanding_amount - (p.total_amount - p.paid_amount)) > 0.01 THEN 1
        WHEN ABS(p.paid_amount - COALESCE(payment_summary.total_payments, 0)) > 0.01 THEN 2
        ELSE 3
    END,
    p.id DESC;

-- ===========================================================================
-- STEP 7: CREATE CLEANUP PROCEDURE
-- ===========================================================================

DELIMITER $$

DROP PROCEDURE IF EXISTS cleanup_balance_sync_logs$$

CREATE PROCEDURE cleanup_balance_sync_logs()
COMMENT 'Clean up old balance sync logs (older than 30 days)'
BEGIN
    DECLARE deleted_count INT DEFAULT 0;
    
    DELETE FROM balance_sync_log 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    SET deleted_count = ROW_COUNT();
    
    SELECT CONCAT('Cleaned up ', deleted_count, ' old balance sync log entries') as result;
END$$

DELIMITER ;

-- ===========================================================================
-- STEP 8: RUN INITIAL SYNC
-- ===========================================================================

-- Run initial balance sync to fix any existing discrepancies
SELECT 'Running initial purchase balance sync...' as message;
SELECT sync_purchase_balances() as initial_sync_result;

-- Test validation
SELECT 'Testing purchase balance validation...' as message;
SELECT validate_purchase_balances() as validation_result;

-- ===========================================================================
-- STEP 9: LOG MIGRATION COMPLETION
-- ===========================================================================

INSERT INTO migration_logs (migration_name, executed_at, description, status)
VALUES (
    '021_install_purchase_balance_system',
    NOW(),
    'Installed complete Purchase Balance Validation System with auto-sync triggers and monitoring views',
    'COMPLETED'
) ON CONFLICT (migration_name) DO UPDATE SET 
    executed_at = NOW(),
    status = 'COMPLETED',
    description = VALUES(description);

-- Success message
SELECT 'ðŸŽ‰ Purchase Balance Validation System installed successfully!' as result,
       'System will now automatically maintain accurate Accounts Payable balances' as description;