package repositories_test

import (
	"app-sistem-akuntansi/models"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestJournalEntryValidation(t *testing.T) {
	tests := []struct {
		name      string
		entry     *models.JournalEntry
		wantValid bool
	}{
		{
			name: "Valid balanced entry",
			entry: &models.JournalEntry{
				Description: "Test transaction",
				Reference:   "REF001",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
				IsBalanced:  true,
			},
			wantValid: true,
		},
		{
			name: "Unbalanced entry",
			entry: &models.JournalEntry{
				Description: "Unbalanced transaction",
				Reference:   "REF002",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 500.00,
				IsBalanced:  false,
			},
			wantValid: false,
		},
		{
			name: "Empty description",
			entry: &models.JournalEntry{
				Description: "",
				Reference:   "REF003",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
				IsBalanced:  true,
			},
			wantValid: false,
		},
		{
			name: "Zero user ID",
			entry: &models.JournalEntry{
				Description: "Test transaction",
				Reference:   "REF004",
				EntryDate:   time.Now(),
				UserID:      0,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
				IsBalanced:  true,
			},
			wantValid: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.entry.ValidateComplete()
			if tt.wantValid {
				assert.NoError(t, err, "Expected entry to be valid")
			} else {
				assert.Error(t, err, "Expected entry to be invalid")
			}
		})
	}
}

func TestJournalEntryBalanceValidation(t *testing.T) {
	tests := []struct {
		name        string
		totalDebit  float64
		totalCredit float64
		wantBalance bool
	}{
		{"Balanced entry", 1000.0, 1000.0, true},
		{"Unbalanced entry", 1000.0, 500.0, false},
		{"Zero amounts", 0.0, 0.0, false},
		{"Negative amounts", -100.0, -100.0, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			entry := &models.JournalEntry{
				Description: "Test transaction",
				Reference:   "REF001",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  tt.totalDebit,
				TotalCredit: tt.totalCredit,
			}

			balanced := entry.ValidateBalance()
			assert.Equal(t, tt.wantBalance, balanced)
		})
	}
}

func TestJournalEntryRequest_Validation(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name    string
		req     *models.JournalEntryCreateRequest
		wantErr bool
	}{
		{
			name: "Valid request",
			req: &models.JournalEntryCreateRequest{
				Description: "Test transaction",
				Reference:   "REF001",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
			},
			wantErr: false,
		},
		{
			name: "Empty description",
			req: &models.JournalEntryCreateRequest{
				Description: "",
				Reference:   "REF002",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
			},
			wantErr: true,
		},
		{
			name: "Zero user ID",
			req: &models.JournalEntryCreateRequest{
				Description: "Test transaction",
				Reference:   "REF003",
				EntryDate:   time.Now(),
				UserID:      0,
				TotalDebit:  1000.00,
				TotalCredit: 1000.00,
			},
			wantErr: true,
		},
		{
			name: "Unbalanced amounts",
			req: &models.JournalEntryCreateRequest{
				Description: "Test transaction",
				Reference:   "REF004",
				EntryDate:   time.Now(),
				UserID:      1,
				TotalDebit:  1000.00,
				TotalCredit: 500.00,
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create journal entry from request to test validation
			entry := &models.JournalEntry{
				Description:     tt.req.Description,
				Reference:       tt.req.Reference,
				EntryDate:       tt.req.EntryDate,
				UserID:          tt.req.UserID,
				TotalDebit:      tt.req.TotalDebit,
				TotalCredit:     tt.req.TotalCredit,
				IsBalanced:      tt.req.TotalDebit == tt.req.TotalCredit && tt.req.TotalDebit > 0,
				Status:          models.JournalStatusDraft,
				IsAutoGenerated: tt.req.IsAutoGenerated,
			}

			err := entry.ValidateComplete()
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			// Test context is not nil
			assert.NotNil(t, ctx)
		})
	}
}

func TestJournalLineValidation(t *testing.T) {
	tests := []struct {
		name     string
		line     *models.JournalLineCreateRequest
		wantErr  bool
		errorMsg string
	}{
		{
			name: "Valid debit line",
			line: &models.JournalLineCreateRequest{
				AccountID:    1,
				Description:  "Cash received",
				DebitAmount:  1000.00,
				CreditAmount: 0,
			},
			wantErr: false,
		},
		{
			name: "Valid credit line",
			line: &models.JournalLineCreateRequest{
				AccountID:    2,
				Description:  "Revenue earned",
				DebitAmount:  0,
				CreditAmount: 1000.00,
			},
			wantErr: false,
		},
		{
			name: "Invalid - zero account ID",
			line: &models.JournalLineCreateRequest{
				AccountID:    0,
				Description:  "Invalid account",
				DebitAmount:  1000.00,
				CreditAmount: 0,
			},
			wantErr:  true,
			errorMsg: "account_id is required",
		},
		{
			name: "Invalid - both debit and credit",
			line: &models.JournalLineCreateRequest{
				AccountID:    1,
				Description:  "Invalid line",
				DebitAmount:  500.00,
				CreditAmount: 500.00,
			},
			wantErr:  true,
			errorMsg: "cannot have both debit and credit amounts",
		},
		{
			name: "Invalid - no amounts",
			line: &models.JournalLineCreateRequest{
				AccountID:    1,
				Description:  "Invalid line",
				DebitAmount:  0,
				CreditAmount: 0,
			},
			wantErr:  true,
			errorMsg: "must have either debit or credit amount",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Basic validation logic
			var err error

			if tt.line.AccountID == 0 {
				err = assert.AnError // Simulate error
			} else if tt.line.DebitAmount > 0 && tt.line.CreditAmount > 0 {
				err = assert.AnError // Simulate error
			} else if tt.line.DebitAmount == 0 && tt.line.CreditAmount == 0 {
				err = assert.AnError // Simulate error
			}

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestJournalEntryConstants(t *testing.T) {
	// Test status constants
	assert.Equal(t, "DRAFT", models.JournalStatusDraft)
	assert.Equal(t, "POSTED", models.JournalStatusPosted)
	assert.Equal(t, "REVERSED", models.JournalStatusReversed)

	// Test reference type constants
	assert.Equal(t, "SALE", models.JournalRefSale)
	assert.Equal(t, "PURCHASE", models.JournalRefPurchase)
	assert.Equal(t, "PAYMENT", models.JournalRefPayment)
	assert.Equal(t, "MANUAL", models.JournalRefManual)
}

func TestJournalEntrySummary(t *testing.T) {
	summary := &models.JournalEntrySummary{
		TotalEntries:    10,
		TotalDebit:      5000.00,
		TotalCredit:     5000.00,
		BalancedEntries: 9,
		StatusCounts: map[string]int64{
			models.JournalStatusDraft:  3,
			models.JournalStatusPosted: 7,
		},
		TypeCounts: map[string]int64{
			models.JournalRefSale:     4,
			models.JournalRefPurchase: 3,
			models.JournalRefManual:   3,
		},
	}

	assert.NotNil(t, summary)
	assert.Equal(t, int64(10), summary.TotalEntries)
	assert.Equal(t, 5000.00, summary.TotalDebit)
	assert.Equal(t, 5000.00, summary.TotalCredit)
	assert.Equal(t, int64(9), summary.BalancedEntries)

	// Verify status counts
	assert.Equal(t, int64(3), summary.StatusCounts[models.JournalStatusDraft])
	assert.Equal(t, int64(7), summary.StatusCounts[models.JournalStatusPosted])

	// Verify type counts
	assert.Equal(t, int64(4), summary.TypeCounts[models.JournalRefSale])
	assert.Equal(t, int64(3), summary.TypeCounts[models.JournalRefPurchase])
	assert.Equal(t, int64(3), summary.TypeCounts[models.JournalRefManual])
}