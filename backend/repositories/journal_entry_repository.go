package repositories

import (
	"app-sistem-akuntansi/models"
	"app-sistem-akuntansi/utils"
	"context"
	"fmt"
	"time"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type JournalEntryRepository interface {
	Create(ctx context.Context, req *models.JournalEntryCreateRequest) (*models.JournalEntry, error)
	FindByID(ctx context.Context, id uint) (*models.JournalEntry, error)
	FindByCode(ctx context.Context, code string) (*models.JournalEntry, error)
	FindAll(ctx context.Context, filter *models.JournalEntryFilter) ([]models.JournalEntry, int64, error)
	Update(ctx context.Context, id uint, req *models.JournalEntryUpdateRequest) (*models.JournalEntry, error)
	Delete(ctx context.Context, id uint) error
	PostJournalEntry(ctx context.Context, id uint, userID uint) error
	ReverseJournalEntry(ctx context.Context, id uint, userID uint, reason string) (*models.JournalEntry, error)
	GetSummary(ctx context.Context) (*models.JournalEntrySummary, error)
	UpdateAccountBalances(ctx context.Context, entry *models.JournalEntry) error
	FindByReferenceID(ctx context.Context, referenceType string, referenceID uint) (*models.JournalEntry, error)
}

type JournalEntryRepo struct {
	DB *gorm.DB
}

func NewJournalEntryRepository(db *gorm.DB) JournalEntryRepository {
	return &JournalEntryRepo{DB: db}
}

// Create creates a new journal entry with validation
func (r *JournalEntryRepo) Create(ctx context.Context, req *models.JournalEntryCreateRequest) (*models.JournalEntry, error) {
	var entry *models.JournalEntry

	err := r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		// Create journal entry
		entry = &models.JournalEntry{
			Description:     req.Description,
			Reference:       req.Reference,
			EntryDate:       req.EntryDate,
			Notes:           req.Notes,
			Status:          models.JournalStatusDraft,
			AccountID:       req.AccountID,
			ReferenceType:   req.ReferenceType,
			ReferenceID:     req.ReferenceID,
			UserID:          req.UserID,
			TotalDebit:      req.TotalDebit,
			TotalCredit:     req.TotalCredit,
			IsBalanced:      req.TotalDebit == req.TotalCredit && req.TotalDebit > 0,
			IsAutoGenerated: req.IsAutoGenerated,
		}

		// Validate entry before saving
		if err := entry.ValidateComplete(); err != nil {
			return utils.NewBadRequestError(fmt.Sprintf("Journal entry validation failed: %v", err))
		}

		// Create the journal entry
		if err := tx.Create(entry).Error; err != nil {
			return utils.NewInternalError("Failed to create journal entry", err)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Reload with relations
	return r.FindByID(ctx, entry.ID)
}

// FindByID finds journal entry by ID
func (r *JournalEntryRepo) FindByID(ctx context.Context, id uint) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Session(&gorm.Session{Logger: logger.Default.LogMode(logger.Silent)}).
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("JournalLines").
		Preload("JournalLines.Account").
		Preload("Account").
		Preload("ReversalEntry").
		Preload("ReversedEntry").
		First(&entry, id).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, utils.NewNotFoundError("Journal entry not found")
		}
		return nil, utils.NewInternalError("Failed to find journal entry", err)
	}

	return &entry, nil
}

// FindByCode finds journal entry by code
func (r *JournalEntryRepo) FindByCode(ctx context.Context, code string) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("Account").
		Where("code = ?", code).
		First(&entry).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, utils.NewNotFoundError("Journal entry not found")
		}
		return nil, utils.NewInternalError("Failed to find journal entry", err)
	}

	return &entry, nil
}

// FindAll finds all journal entries with filtering
func (r *JournalEntryRepo) FindAll(ctx context.Context, filter *models.JournalEntryFilter) ([]models.JournalEntry, int64, error) {
	var entries []models.JournalEntry
	var total int64

	query := r.DB.WithContext(ctx).Model(&models.JournalEntry{})

	// Apply filters
	if filter.Status != "" {
		query = query.Where("status = ?", filter.Status)
	}
	if filter.ReferenceType != "" {
		query = query.Where("reference_type = ?", filter.ReferenceType)
	}
	if filter.AccountID != "" {
		query = query.Where("account_id = ?", filter.AccountID)
	}
	if filter.StartDate != "" {
		query = query.Where("entry_date >= ?", filter.StartDate)
	}
	if filter.EndDate != "" {
		query = query.Where("entry_date <= ?", filter.EndDate)
	}
	if filter.Search != "" {
		query = query.Where("description ILIKE ? OR reference ILIKE ?", "%"+filter.Search+"%", "%"+filter.Search+"%")
	}

	// Get total count
	err := query.Count(&total).Error
	if err != nil {
		return nil, 0, utils.NewInternalError("Failed to count journal entries", err)
	}

	// Apply pagination
	page := filter.Page
	if page <= 0 {
		page = 1
	}
	limit := filter.Limit
	if limit <= 0 {
		limit = 20
	}

	offset := (page - 1) * limit
	query = query.Offset(offset).Limit(limit)

	// Load with preloads
	err = query.Preload("Creator").Preload("Poster").Order("entry_date DESC").Find(&entries).Error
	if err != nil {
		return nil, 0, utils.NewInternalError("Failed to find journal entries", err)
	}

	return entries, total, nil
}

// Update updates a journal entry
func (r *JournalEntryRepo) Update(ctx context.Context, id uint, req *models.JournalEntryUpdateRequest) (*models.JournalEntry, error) {
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}

	if entry.Status != models.JournalStatusDraft {
		return nil, utils.NewBadRequestError("Only draft journal entries can be updated")
	}

	err = r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		updates := make(map[string]interface{})

		if req.Description != nil {
			updates["description"] = *req.Description
		}
		if req.Reference != nil {
			updates["reference"] = *req.Reference
		}
		if req.EntryDate != nil {
			updates["entry_date"] = *req.EntryDate
		}
		if req.Notes != nil {
			updates["notes"] = *req.Notes
		}

		// Handle journal lines update if provided
		if len(req.JournalLines) > 0 {
			// Delete existing lines
			if err := tx.Where("journal_entry_id = ?", entry.ID).Delete(&models.JournalLine{}).Error; err != nil {
				return utils.NewInternalError("Failed to delete existing journal lines", err)
			}

			var totalDebit, totalCredit float64

			// Create new lines
			for i, lineReq := range req.JournalLines {
				// Validate account exists and is active
				var account models.Account
				if err := tx.First(&account, lineReq.AccountID).Error; err != nil {
					if err == gorm.ErrRecordNotFound {
						return utils.NewBadRequestError(fmt.Sprintf("Account %d not found", lineReq.AccountID))
					}
					return utils.NewInternalError("Failed to validate account", err)
				}

				if account.IsHeader {
					return utils.NewBadRequestError(fmt.Sprintf("Cannot post to header account %s (%s)", account.Name, account.Code))
				}

				if !account.IsActive {
					return utils.NewBadRequestError(fmt.Sprintf("Account %s (%s) is inactive", account.Name, account.Code))
				}

				line := &models.JournalLine{
					JournalEntryID: entry.ID,
					AccountID:      lineReq.AccountID,
					Description:    lineReq.Description,
					DebitAmount:    lineReq.DebitAmount,
					CreditAmount:   lineReq.CreditAmount,
					LineNumber:     i + 1,
				}

				if err := tx.Create(line).Error; err != nil {
					return utils.NewInternalError("Failed to create journal line", err)
				}

				totalDebit += lineReq.DebitAmount
				totalCredit += lineReq.CreditAmount
			}

			// Update entry totals
			updates["total_debit"] = totalDebit
			updates["total_credit"] = totalCredit
			updates["is_balanced"] = (totalDebit == totalCredit) && (totalDebit > 0)
		}

		if len(updates) > 0 {
			if err := tx.Model(entry).Updates(updates).Error; err != nil {
				return utils.NewInternalError("Failed to update journal entry", err)
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return r.FindByID(ctx, entry.ID)
}

// Delete deletes a journal entry
func (r *JournalEntryRepo) Delete(ctx context.Context, id uint) error {
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return err
	}

	if entry.Status != models.JournalStatusDraft {
		return utils.NewBadRequestError("Only draft journal entries can be deleted")
	}

	return r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		// Delete journal lines first
		if err := tx.Where("journal_entry_id = ?", id).Delete(&models.JournalLine{}).Error; err != nil {
			return utils.NewInternalError("Failed to delete journal lines", err)
		}

		// Delete journal entry
		if err := tx.Delete(&models.JournalEntry{}, id).Error; err != nil {
			return utils.NewInternalError("Failed to delete journal entry", err)
		}

		return nil
	})
}

// PostJournalEntry posts a journal entry
func (r *JournalEntryRepo) PostJournalEntry(ctx context.Context, id uint, userID uint) error {
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return err
	}

	if entry.Status != models.JournalStatusDraft {
		return utils.NewBadRequestError("Only draft journal entries can be posted")
	}

	if !entry.IsBalanced {
		return utils.NewBadRequestError("Journal entry must be balanced to post")
	}

	return r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		// Update account balances
		if err := r.updateAccountBalancesInTx(tx, entry); err != nil {
			return err
		}

		// Update entry status
		now := time.Now()
		err := tx.Model(entry).Updates(map[string]interface{}{
			"status":       models.JournalStatusPosted,
			"posted_by":    userID,
			"posting_date": now,
		}).Error

		return err
	})
}

// updateAccountBalancesInTx updates account balances within a transaction
func (r *JournalEntryRepo) updateAccountBalancesInTx(tx *gorm.DB, entry *models.JournalEntry) error {
	// Load journal lines if not already loaded
	if len(entry.JournalLines) == 0 {
		var lines []models.JournalLine
		if err := tx.Where("journal_entry_id = ?", entry.ID).Find(&lines).Error; err != nil {
			return utils.NewInternalError("Failed to load journal lines", err)
		}
		entry.JournalLines = lines
	}

	// If no lines and has primary account, update primary account
	if len(entry.JournalLines) == 0 && entry.AccountID != nil {
		balanceChange := entry.TotalDebit - entry.TotalCredit
		result := tx.Model(&models.Account{}).
			Where("id = ? AND deleted_at IS NULL", *entry.AccountID).
			Update("balance", gorm.Expr("balance + ?", balanceChange))

		if result.Error != nil {
			return utils.NewInternalError("Failed to update account balance", result.Error)
		}

		if result.RowsAffected == 0 {
			return utils.NewBadRequestError(fmt.Sprintf("Account %d not found or inactive", *entry.AccountID))
		}

		return nil
	}

	// Process journal lines
	for _, line := range entry.JournalLines {
		if line.AccountID == 0 {
			return utils.NewBadRequestError("Invalid account ID in journal line")
		}

		// Get account details to determine normal balance type
		var account models.Account
		if err := tx.Select("id, code, name, type, balance").First(&account, line.AccountID).Error; err != nil {
			return utils.NewInternalError(fmt.Sprintf("Failed to get account %d details", line.AccountID), err)
		}

		// Calculate balance change based on account type (normal balance)
		var balanceChange float64
		if account.Type == "ASSET" || account.Type == "EXPENSE" {
			// Debit normal accounts: debit increases, credit decreases
			balanceChange = line.DebitAmount - line.CreditAmount
		} else {
			// Credit normal accounts (LIABILITY, EQUITY, REVENUE): credit increases, debit decreases
			balanceChange = line.CreditAmount - line.DebitAmount
		}

		// Update account balance atomically
		result := tx.Model(&models.Account{}).
			Where("id = ? AND deleted_at IS NULL", line.AccountID).
			Update("balance", gorm.Expr("balance + ?", balanceChange))

		if result.Error != nil {
			return utils.NewInternalError(fmt.Sprintf("Failed to update balance for account %d", line.AccountID), result.Error)
		}

		if result.RowsAffected == 0 {
			return utils.NewBadRequestError(fmt.Sprintf("Account %d not found or inactive", line.AccountID))
		}

		// Log balance update for audit trail
		var updatedAccount models.Account
		if err := tx.Select("id, code, name, balance").First(&updatedAccount, line.AccountID).Error; err == nil {
			fmt.Printf("✅ Updated balance for account %s (%s): change=%.2f, new_balance=%.2f\n",
				updatedAccount.Code, updatedAccount.Name, balanceChange, updatedAccount.Balance)
		}

		// Update parent account balances after each account balance change
		if err := r.updateParentAccountBalances(tx, line.AccountID); err != nil {
			fmt.Printf("⚠️ Warning: Failed to update parent balances for account %d: %v\n", line.AccountID, err)
			// Continue processing, don't fail the entire transaction
		}
	}

	return nil
}

// updateParentAccountBalances updates parent account balances for a given account
func (r *JournalEntryRepo) updateParentAccountBalances(tx *gorm.DB, accountID uint) error {
	var parentID *uint
	
	// Get parent ID
	if err := tx.Raw("SELECT parent_id FROM accounts WHERE id = ? AND deleted_at IS NULL", accountID).Scan(&parentID).Error; err != nil {
		return fmt.Errorf("failed to get parent ID for account %d: %w", accountID, err)
	}
	
	// If has parent, update parent and continue up the chain
	if parentID != nil {
		// Calculate parent balance as sum of children
		var parentBalance float64
		if err := tx.Raw(`
			SELECT COALESCE(SUM(balance), 0)
			FROM accounts 
			WHERE parent_id = ? AND deleted_at IS NULL
		`, *parentID).Scan(&parentBalance).Error; err != nil {
			return fmt.Errorf("failed to calculate parent balance for account %d: %w", *parentID, err)
		}

		// Update parent balance
		if err := tx.Model(&models.Account{}).
			Where("id = ? AND deleted_at IS NULL", *parentID).
			Update("balance", parentBalance).Error; err != nil {
			return fmt.Errorf("failed to update parent balance for account %d: %w", *parentID, err)
		}

		// Recursively update grandparent chain
		return r.updateParentAccountBalances(tx, *parentID)
	}
	
	return nil
}

// ReverseJournalEntry creates a reversing entry
func (r *JournalEntryRepo) ReverseJournalEntry(ctx context.Context, id uint, userID uint, reason string) (*models.JournalEntry, error) {
	originalEntry, err := r.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}

	if originalEntry.Status != models.JournalStatusPosted {
		return nil, utils.NewBadRequestError("Only posted journal entries can be reversed")
	}

	if originalEntry.ReversalID != nil {
		return nil, utils.NewBadRequestError("Journal entry has already been reversed")
	}

	var reversalEntry *models.JournalEntry

	err = r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		// Load original lines
		var originalLines []models.JournalLine
		if err := tx.Where("journal_entry_id = ?", originalEntry.ID).Find(&originalLines).Error; err != nil {
			return utils.NewInternalError("Failed to load original journal lines", err)
		}

		// Create reversal entry
		reversalEntry = &models.JournalEntry{
			Description:     fmt.Sprintf("REVERSAL: %s - %s", originalEntry.Description, reason),
			Reference:       fmt.Sprintf("REV-%s", originalEntry.Reference),
			ReferenceType:   originalEntry.ReferenceType,
			ReferenceID:     originalEntry.ReferenceID,
			EntryDate:       time.Now(),
			UserID:          userID,
			PostedBy:        &userID,
			PostingDate:     &[]time.Time{time.Now()}[0],
			Status:          models.JournalStatusPosted,
			TotalDebit:      originalEntry.TotalCredit, // Swap debits and credits
			TotalCredit:     originalEntry.TotalDebit,
			IsBalanced:      true,
			IsAutoGenerated: false,
			ReversedID:      &originalEntry.ID,
			Notes:           fmt.Sprintf("Reversal of entry. Reason: %s", reason),
		}

		if err := tx.Create(reversalEntry).Error; err != nil {
			return utils.NewInternalError("Failed to create reversal entry", err)
		}

		// Create reversal lines (swap debit/credit)
		for i, originalLine := range originalLines {
			reversalLine := &models.JournalLine{
				JournalEntryID: reversalEntry.ID,
				AccountID:      originalLine.AccountID,
				Description:    fmt.Sprintf("REVERSAL: %s", originalLine.Description),
				DebitAmount:    originalLine.CreditAmount, // Swap amounts
				CreditAmount:   originalLine.DebitAmount,
				LineNumber:     i + 1,
			}

			if err := tx.Create(reversalLine).Error; err != nil {
				return utils.NewInternalError("Failed to create reversal line", err)
			}
		}

		// Update account balances for reversal
		reversalEntry.JournalLines = make([]models.JournalLine, len(originalLines))
		for i, originalLine := range originalLines {
			reversalEntry.JournalLines[i] = models.JournalLine{
				AccountID:    originalLine.AccountID,
				DebitAmount:  originalLine.CreditAmount,
				CreditAmount: originalLine.DebitAmount,
			}
		}

		if err := r.updateAccountBalancesInTx(tx, reversalEntry); err != nil {
			return err
		}

		// Mark original entry as reversed
		if err := tx.Model(originalEntry).Update("reversal_id", reversalEntry.ID).Error; err != nil {
			return utils.NewInternalError("Failed to mark original entry as reversed", err)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Reload with relations
	return r.FindByID(ctx, reversalEntry.ID)
}

// GetSummary returns summary statistics
func (r *JournalEntryRepo) GetSummary(ctx context.Context) (*models.JournalEntrySummary, error) {
	var summary models.JournalEntrySummary

	// Get total entries and amounts
	var totalResult struct {
		TotalEntries int64   `json:"total_entries"`
		TotalDebit   float64 `json:"total_debit"`
		TotalCredit  float64 `json:"total_credit"`
	}

	err := r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("COUNT(*) as total_entries, COALESCE(SUM(total_debit), 0) as total_debit, COALESCE(SUM(total_credit), 0) as total_credit").
		Where("deleted_at IS NULL").
		Scan(&totalResult).Error

	if err != nil {
		return nil, utils.NewInternalError("Failed to get journal entries summary", err)
	}

	summary.TotalEntries = totalResult.TotalEntries
	summary.TotalDebit = totalResult.TotalDebit
	summary.TotalCredit = totalResult.TotalCredit

	// Count balanced entries
	if err := r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Where("is_balanced = ? AND deleted_at IS NULL", true).
		Count(&summary.BalancedEntries).Error; err != nil {
		return nil, utils.NewInternalError("Failed to count balanced entries", err)
	}

	// Get status counts
	summary.StatusCounts = make(map[string]int64)
	var statusCounts []struct {
		Status string `json:"status"`
		Count  int64  `json:"count"`
	}

	if err := r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("status, COUNT(*) as count").
		Where("deleted_at IS NULL").
		Group("status").
		Scan(&statusCounts).Error; err != nil {
		return nil, utils.NewInternalError("Failed to get status counts", err)
	}

	for _, sc := range statusCounts {
		summary.StatusCounts[sc.Status] = sc.Count
	}

	// Get type counts
	summary.TypeCounts = make(map[string]int64)
	var typeCounts []struct {
		ReferenceType string `json:"reference_type"`
		Count         int64  `json:"count"`
	}

	if err := r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("reference_type, COUNT(*) as count").
		Where("deleted_at IS NULL AND reference_type IS NOT NULL AND reference_type != ''").
		Group("reference_type").
		Scan(&typeCounts).Error; err != nil {
		return nil, utils.NewInternalError("Failed to get type counts", err)
	}

	for _, tc := range typeCounts {
		summary.TypeCounts[tc.ReferenceType] = tc.Count
	}

	return &summary, nil
}

// UpdateAccountBalances updates account balances for a journal entry (external interface)
func (r *JournalEntryRepo) UpdateAccountBalances(ctx context.Context, entry *models.JournalEntry) error {
	return r.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		return r.updateAccountBalancesInTx(tx, entry)
	})
}

// FindByReferenceID finds journal entry by reference type and ID
func (r *JournalEntryRepo) FindByReferenceID(ctx context.Context, referenceType string, referenceID uint) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Preload("JournalLines").
		Preload("JournalLines.Account").
		Where("reference_type = ? AND reference_id = ?", referenceType, referenceID).
		First(&entry).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil // Not found, but not an error
		}
		return nil, utils.NewInternalError("Failed to find journal entry by reference", err)
	}

	return &entry, nil
}